<script>
(function () {
  // ---- Minimal status + hard guards ----
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const statusEl = document.getElementById('status');
  const errEl = document.getElementById('error');
  const mm = (m)=> statusEl.textContent = m;

  // Show any runtime errors in red
  window.addEventListener('error', e => {
    errEl.textContent = String(e.error || e.message || e);
  });

  // If we ever get here, JS at least started:
  mm('boot…');

  // ---- Config ----
  const SOCIAL_URL = '/social';
  const CUTOFF_ISO = '2025-09-22';
  const TW_HOSTS = new Set(['twitter.com','x.com','mobile.twitter.com']);

  // Zoom/pan
  let zoomTransform = d3 && d3.zoomIdentity ? d3.zoomIdentity : {x:0,y:0,k:1};
  function project(x,y){ return [zoomTransform.x + x*zoomTransform.k, zoomTransform.y + y*zoomTransform.k]; }
  function unproject(x,y){
    const k = zoomTransform.k || 1;
    return [(x - zoomTransform.x)/k, (y - zoomTransform.y)/k];
  }

  // Retina canvas
  function fitCanvas() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const { clientWidth:w, clientHeight:h } = canvas.parentElement;
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', () => { fitCanvas(); render(); });

  // UI
  const minCountInput = document.getElementById('minCount');
  const minCountLabel = document.getElementById('minCountLabel');
  minCountInput.addEventListener('input', () => {
    minCountLabel.textContent = minCountInput.value;
    recomputeAndRender();
  });

  // ---- Helpers ----
  function parseDateFromDataDate(val) {
    if (!val) return null;
    const s = String(val).trim();
    if (/^\d{6}$/.test(s)) { // MMDDYY
      const mm = +s.slice(0,2), dd = +s.slice(2,4), yy = +s.slice(4,6);
      const d = new Date(2000 + yy, mm-1, dd);
      return isNaN(d) ? null : d;
    }
    if (/^\d{8}$/.test(s)) { // MMDDYYYY
      const mm = +s.slice(0,2), dd = +s.slice(2,4), yyyy = +s.slice(4,8);
      const d = new Date(yyyy, mm-1, dd);
      return isNaN(d) ? null : d;
    }
    return null;
  }
  function getCutoffDate() {
    const [y,m,d] = CUTOFF_ISO.split('-').map(Number);
    return new Date(y, m-1, d);
  }
  function daysAgo(date) {
    const ms = Date.now() - date.getTime();
    return Math.max(0, Math.floor(ms / 86400000));
  }
  function extractHandleFromHref(href) {
    try {
      const u = new URL(href, location.origin);
      if (TW_HOSTS.has(u.hostname)) {
        const seg = u.pathname.split('/').filter(Boolean)[0] || '';
        return seg.replace(/^@/, '').trim();
      }
      return null;
    } catch { return null; }
  }

  // ---- Data ----
  let rawPosts = [];           // [{date, handles:Set}]
  let graph = { nodes:[], links:[] };
  let sim = null;
  const labels = new Map();

  // Fetch & parse /social
  async function loadSocial() {
    mm('fetching /social…');
    const res = await fetch(SOCIAL_URL, { credentials: 'same-origin' });
    if (!res.ok) throw new Error('Failed to fetch /social');
    const html = await res.text();
    const doc = new DOMParser().parseFromString(html, 'text/html');

    const cutoff = getCutoffDate();
    const nodes = Array.from(doc.querySelectorAll('p[data-type="social"][data-date]'));
    mm(`found ${nodes.length} social nodes`);

    const posts = [];
    nodes.forEach(el => {
      const date = parseDateFromDataDate(el.getAttribute('data-date'));
      if (!date || date < cutoff) return;

      const handles = new Set();
      el.querySelectorAll('a[href]').forEach(a => {
        const h = extractHandleFromHref(a.getAttribute('href'));
        if (h) handles.add(h.toLowerCase());
      });
      if (handles.size >= 1) posts.push({ date, handles });
    });

    posts.sort((a,b) => a.date - b.date);
    rawPosts = posts;
    mm(`parsed ${posts.length} posts since 2025-09-22`);
  }

  // Build graph
  function buildGraph(minMentions=1) {
    const mentionCounts = new Map();
    rawPosts.forEach(p => p.handles.forEach(h => mentionCounts.set(h, (mentionCounts.get(h)||0)+1)));

    const eligible = new Set([...mentionCounts.entries()]
      .filter(([,c]) => c >= minMentions)
      .map(([h]) => h));

    const linkKey = (a,b) => a < b ? `${a}|${b}` : `${b}|${a}`;
    const linksMap = new Map();

    rawPosts.forEach(p => {
      const hs = [...p.handles].filter(h => eligible.has(h));
      if (hs.length < 2) return;
      const w = Math.max(0, 1 - 0.01 * daysAgo(p.date));
      for (let i=0;i<hs.length;i++) for (let j=i+1;j<hs.length;j++) {
        const a = hs[i], b = hs[j];
        const key = linkKey(a,b);
        const prev = linksMap.get(key) || { source:a, target:b, value:0, count:0 };
        prev.value += w; prev.count += 1;
        linksMap.set(key, prev);
      }
    });

    const nodes = [...eligible].map(h => ({ id:h, handle:h, mentions: mentionCounts.get(h)||0 }));
    const links = [...linksMap.values()];
    return { nodes, links, mentionCounts };
  }

  // Distances
  let VMIN = 0, VMAX = 1;
  function updateLinkStats() {
    const vals = graph.links.map(l => l.value || 0);
    if (!vals.length) { VMIN=0; VMAX=1; return; }
    VMIN = Math.min(...vals);
    VMAX = Math.max(...vals);
    if (VMAX === VMIN) VMAX = VMIN + 1;
  }
  function nodeRadius(n) { return 4 + Math.min(14, n.mentions * 1.2); }
  function linkWidth(_) { return 0.4; }
  function linkDistance(l) {
    const w = canvas.parentElement.clientWidth;
    const h = canvas.parentElement.clientHeight;
    const dMin = 26;
    const dMax = Math.max(140, 0.55 * Math.min(w, h));
    const v = (l.value || 0);
    const t = (v - VMIN) / (VMAX - VMIN);
    return dMax - t * (dMax - dMin); // stronger → shorter
  }

  // Labels
  function clearLabels(){ labels.forEach(el => el.remove()); labels.clear(); }
  function placeLabel(node) {
    let el = labels.get(node.id);
    if (!el) {
      el = document.createElement('a');
      el.href = `https://twitter.com/${node.handle}`;
      el.target = '_blank'; el.rel = 'noopener';
      el.style.position = 'absolute';
      el.style.color = '#fff';
      el.style.textDecoration = 'none';
      el.style.fontSize = '12px';
      el.style.padding = '2px 3px';
      el.style.borderRadius = '6px';
      el.textContent = '@' + node.handle;
      canvas.parentElement.appendChild(el);
      labels.set(node.id, el);
    }
    const [sx, sy] = project(node.x || 0, node.y || 0);
    const r = nodeRadius(node);
    const rect = el.getBoundingClientRect();
    el.style.left = (sx - rect.width/2) + 'px';
    el.style.top  = (sy - (r * (zoomTransform.k||1)) - rect.height - 4) + 'px';
  }

  // Render (always paints a black background first so you never see white)
  function render() {
    const { clientWidth:w, clientHeight:h } = canvas;
    // black background safety
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,w,h);
    ctx.restore();

    if (!graph.nodes.length) { clearLabels(); return; }

    ctx.save();
    ctx.translate(zoomTransform.x||0, zoomTransform.y||0);
    ctx.scale(zoomTransform.k||1, zoomTransform.k||1);

    // edges
    ctx.globalAlpha = 0.9;
    graph.links.forEach(l => {
      ctx.beginPath();
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = linkWidth(l);
      ctx.moveTo(l.source.x, l.source.y);
      ctx.lineTo(l.target.x, l.target.y);
      ctx.stroke();
    });

    // nodes (hollow)
    graph.nodes.forEach(n => {
      ctx.beginPath();
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 1.2 / Math.max(1, (zoomTransform.k||1) * 0.9);
      ctx.arc(n.x, n.y, nodeRadius(n), 0, Math.PI * 2);
      ctx.stroke();
    });

    ctx.restore();
    graph.nodes.forEach(n => placeLabel(n));
  }

  // Start simulation
  function startSim() {
    if (!window.d3 || !d3.forceSimulation) throw new Error('D3 failed to load');
    if (sim) sim.stop();

    const w = canvas.parentElement.clientWidth;
    const h = canvas.parentElement.clientHeight;

    // seed grid
    graph.nodes.forEach((n, i) => {
      if (typeof n.x !== 'number' || typeof n.y !== 'number') {
        const cols = Math.ceil(Math.sqrt(graph.nodes.length));
        const x = (i % cols) / (cols - 1 || 1);
        const y = Math.floor(i / cols) / (cols - 1 || 1);
        n.x = 40 + x * (w - 80) + (Math.random() - 0.5) * 24;
        n.y = 40 + y * (h - 80) + (Math.random() - 0.5) * 24;
      }
    });

    updateLinkStats();

    sim = d3.forceSimulation(graph.nodes)
      .force('link', d3.forceLink(graph.links)
        .id(d => d.id)
        .distance(linkDistance)
        .strength(l => 0.15 + 0.85 * ((l.value - VMIN) / (VMAX - VMIN)))
      )
      .force('charge', d3.forceManyBody().strength(-320))
      .force('center', d3.forceCenter(w/2, h/2))
      .force('collide', d3.forceCollide().radius(d => nodeRadius(d) + 12).iterations(2))
      .velocityDecay(0.25)
      .on('tick', render);
  }

  // Hover
  const tooltip = document.getElementById('tooltip');
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const [ux, uy] = unproject(e.clientX - rect.left, e.clientY - rect.top);
    const hit = (() => {
      for (let i = graph.nodes.length - 1; i >= 0; i--) {
        const n = graph.nodes[i], r = nodeRadius(n);
        const dx = ux - n.x, dy = uy - n.y;
        if (dx*dx + dy*dy <= r*r) return n;
      }
      return null;
    })();
    if (hit) {
      tooltip.style.display = 'block';
      tooltip.textContent = `@${hit.handle} — mentions: ${hit.mentions}`;
      tooltip.style.left = e.clientX + 'px';
      tooltip.style.top  = e.clientY + 'px';
    } else {
      tooltip.style.display = 'none';
    }
  });

  // Recompute
  function recomputeAndRender() {
    const minMentions = parseInt(minCountInput.value, 10) || 1;
    graph = buildGraph(minMentions);
    clearLabels();
    fitCanvas();
    updateLinkStats();
    // If graph empty, still render black bg so it’s never white
    render();
    if (graph.nodes.length) startSim();
  }

  // Init
  (async function init() {
    try {
      fitCanvas();
      // Zoom only if d3 is present
      if (window.d3 && d3.zoom) {
        d3.select(canvas)
          .call(d3.zoom()
            .scaleExtent([0.25, 6])
            .on('zoom', (event) => { zoomTransform = event.transform; render(); })
          )
          .on('dblclick.zoom', null);
      } else {
        mm('warning: d3 not loaded; zoom disabled');
      }

      // Paint black immediately so you never see white
      render();

      await loadSocial();
      recomputeAndRender();
    } catch (err) {
      console.error(err);
      errEl.textContent = String(err.message || err);
    }
  })();
})();
</script>

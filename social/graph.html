<script>
(function () {
  // --- Configuration ---
  const SOCIAL_URL = '/social';
  const CUTOFF_ISO = '2025-09-22';
  const TW_HOSTS = new Set(['twitter.com','x.com','mobile.twitter.com']);

  // Canvas & DOM
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const tooltip = document.getElementById('tooltip');
  const statusEl = document.getElementById('status');
  const errEl = document.getElementById('error');

  // Zoom/pan
  let zoomTransform = d3.zoomIdentity;
  function project(x, y) { return [zoomTransform.applyX(x), zoomTransform.applyY(y)]; }
  function unproject(x, y) { return [zoomTransform.invertX(x), zoomTransform.invertY(y)]; }

  // Resize
  function fitCanvas() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const { clientWidth:w, clientHeight:h } = canvas.parentElement;
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', () => { fitCanvas(); render(); });

  // UI
  const minCountInput = document.getElementById('minCount');
  const minCountLabel = document.getElementById('minCountLabel');
  minCountInput.addEventListener('input', () => {
    minCountLabel.textContent = minCountInput.value;
    recomputeAndRender();
  });

  // --- Parsing helpers ---
  function parseDateFromText(t) {
    if (!t) return null;
    const s = t.trim();
    let m = s.match(/(20\d{2})[-\/\. ](\d{1,2})[-\/\. ](\d{1,2})/);
    if (m) {
      const d = new Date(Number(m[1]), Number(m[2])-1, Number(m[3]));
      return isNaN(d) ? null : d;
    }
    const mn = '(?:jan|feb|mar|apr|may|jun|jul|aug|sep|sept|oct|nov|dec|january|february|march|april|june|july|august|september|october|november|december)';
    m = s.toLowerCase().match(new RegExp(`${mn}\\.?(?:ember|uary|ch|il|e|y|ust|tember|ober|ember|c)?\\s+\\d{1,2},?\\s+20\\d{2}`));
    if (m) {
      const d = new Date(m[0]);
      return isNaN(d) ? null : d;
    }
    return null;
  }
  function parseDateFromDataDate(val) {
    if (!val) return null;
    const s = String(val).trim();
    if (/^\d{6}$/.test(s)) {
      const mm = +s.slice(0,2), dd = +s.slice(2,4), yy = +s.slice(4,6);
      const d = new Date(2000 + yy, mm-1, dd);
      return isNaN(d) ? null : d;
    }
    if (/^\d{8}$/.test(s)) {
      const mm = +s.slice(0,2), dd = +s.slice(2,4), yyyy = +s.slice(4,8);
      const d = new Date(yyyy, mm-1, dd);
      return isNaN(d) ? null : d;
    }
    return null;
  }
  function getCutoffDate() {
    const [y,m,d] = CUTOFF_ISO.split('-').map(Number);
    return new Date(y, m-1, d);
  }
  function daysAgo(date) {
    const ms = Date.now() - date.getTime();
    return Math.max(0, Math.floor(ms / 86400000));
  }
  function extractHandleFromHref(href) {
    try {
      const u = new URL(href, location.origin);
      if (TW_HOSTS.has(u.hostname)) {
        const seg = u.pathname.split('/').filter(Boolean)[0] || '';
        return seg.replace(/^@/, '').trim();
      }
      return null;
    } catch { return null; }
  }

  // --- Fetch & parse /social ---
  let rawPosts = []; // [{date, handles:Set<string>}]

  async function loadSocial() {
    statusEl.textContent = 'Loading /social…';
    const res = await fetch(SOCIAL_URL, { credentials: 'same-origin' });
    if (!res.ok) throw new Error('Failed to fetch /social');
    const html = await res.text();
    const doc = new DOMParser().parseFromString(html, 'text/html');

    const cutoff = getCutoffDate();
    let nodes = Array.from(doc.querySelectorAll('[data-type="social"]'));
    if (!nodes.length) nodes = Array.from(doc.querySelectorAll('p, article, .post, .entry'));

    const posts = [];
    nodes.forEach(el => {
      let date = null;
      const dd = el.getAttribute('data-date') || el.dataset?.date;
      if (dd) date = parseDateFromDataDate(dd);
      if (!date) {
        const t = el.querySelector('time[datetime]') || el.closest('article')?.querySelector('time[datetime]');
        if (t) {
          const d = new Date(t.getAttribute('datetime'));
          if (!isNaN(d)) date = d;
        }
      }
      if (!date) date = parseDateFromText(el.textContent || '');
      if (!date || date < cutoff) return;

      const handles = new Set();
      el.querySelectorAll('a[href]').forEach(a => {
        const h = extractHandleFromHref(a.getAttribute('href'));
        if (h) handles.add(h.toLowerCase());
      });
      handles.add('quasimatt'); // always include @quasimatt
      if (handles.size >= 1) posts.push({ date, handles });
    });

    posts.sort((a,b) => a.date - b.date);
    rawPosts = posts;
    statusEl.textContent = `Parsed ${posts.length} posts since 2025-09-22.`;
  }

  // --- Build graph ---
  function buildGraph(minMentions=1) {
    const mentionCounts = new Map();
    rawPosts.forEach(p => p.handles.forEach(h => mentionCounts.set(h, (mentionCounts.get(h)||0)+1)));
    const eligible = new Set([...mentionCounts.entries()].filter(([,c]) => c >= minMentions).map(([h]) => h));

    const linkKey = (a,b) => a < b ? `${a}|${b}` : `${b}|${a}`;
    const linksMap = new Map();

    rawPosts.forEach(p => {
      const hs = [...p.handles].filter(h => eligible.has(h));
      if (hs.length < 2) return;
      const w = Math.max(0, 1 - 0.01 * daysAgo(p.date));
      for (let i=0;i<hs.length;i++) for (let j=i+1;j<hs.length;j++) {
        const a = hs[i], b = hs[j];
        const key = linkKey(a,b);
        const prev = linksMap.get(key) || { source:a, target:b, value:0, count:0 };
        prev.value += w; prev.count += 1;
        linksMap.set(key, prev);
      }
    });

    const nodes = [...eligible].map(h => ({ id:h, handle:h, mentions: mentionCounts.get(h)||0 }));
    const links = [...linksMap.values()];
    return { nodes, links, mentionCounts };
  }

  // --- Layout + Render ---
  let sim = null;
  let graph = { nodes:[], links:[] };
  const labels = new Map();

  // edge length mapping (normalize by min/max)
  let VMIN = 0, VMAX = 1;
  function updateLinkStats() {
    const vals = graph.links.map(l => l.value || 0);
    if (!vals.length) { VMIN=0; VMAX=1; return; }
    VMIN = Math.min(...vals);
    VMAX = Math.max(...vals);
    if (VMAX === VMIN) VMAX = VMIN + 1;
  }

  function nodeRadius(n) { return 4 + Math.min(14, n.mentions * 1.2); }
  function linkWidth(_) { return 0.4; }
  function linkDistance(l) {
    const w = canvas.parentElement.clientWidth;
    const h = canvas.parentElement.clientHeight;
    const dMin = 26;
    const dMax = Math.max(140, 0.55 * Math.min(w, h));
    const v = (l.value || 0);
    const t = (v - VMIN) / (VMAX - VMIN);
    return dMax - t * (dMax - dMin);
  }

  function clearLabels() { labels.forEach(el => el.remove()); labels.clear(); }
  function placeLabel(node) {
    let el = labels.get(node.id);
    if (!el) {
      el = document.createElement('a');
      el.href = `https://twitter.com/${node.handle}`;
      el.target = '_blank'; el.rel = 'noopener';
      el.style.position = 'absolute';
      el.style.color = '#fff';
      el.style.textDecoration = 'none';
      el.style.fontSize = '12px';
      el.style.padding = '2px 3px';
      el.style.borderRadius = '6px';
      el.textContent = '@' + node.handle;
      canvas.parentElement.appendChild(el);
      labels.set(node.id, el);
    }
    const [sx, sy] = project(node.x || 0, node.y || 0);
    const r = nodeRadius(node);
    const rect = el.getBoundingClientRect();
    const cx = sx - rect.width/2;
    const cy = sy - (r * zoomTransform.k) - rect.height - 4;
    el.style.left = cx + 'px';
    el.style.top = cy + 'px';
  }

  function render() {
    const { clientWidth: w, clientHeight: h } = canvas;
    ctx.clearRect(0, 0, w, h);
    if (!graph.nodes.length) { clearLabels(); return; }

    ctx.save();
    ctx.translate(zoomTransform.x, zoomTransform.y);
    ctx.scale(zoomTransform.k, zoomTransform.k);

    // edges
    ctx.globalAlpha = 0.9;
    graph.links.forEach(l => {
      ctx.beginPath();
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = linkWidth(l);
      ctx.moveTo(l.source.x, l.source.y);
      ctx.lineTo(l.target.x, l.target.y);
      ctx.stroke();
    });

    // nodes (hollow)
    graph.nodes.forEach(n => {
      ctx.beginPath();
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 1.2 / Math.max(1, zoomTransform.k * 0.9);
      ctx.arc(n.x, n.y, nodeRadius(n), 0, Math.PI * 2);
      ctx.stroke();
    });

    ctx.restore();

    // labels
    graph.nodes.forEach(n => placeLabel(n));
  }

  function startSim() {
    if (sim) sim.stop();

    const w = canvas.parentElement.clientWidth;
    const h = canvas.parentElement.clientHeight;

    // seed on a jittered grid
    graph.nodes.forEach((n, i) => {
      if (typeof n.x !== 'number' || typeof n.y !== 'number') {
        const cols = Math.ceil(Math.sqrt(graph.nodes.length));
        const x = (i % cols) / (cols - 1 || 1);
        const y = Math.floor(i / cols) / (cols - 1 || 1);
        n.x = 40 + x * (w - 80) + (Math.random() - 0.5) * 24;
        n.y = 40 + y * (h - 80) + (Math.random() - 0.5) * 24;
      }
    });

    updateLinkStats();

    sim = d3.forceSimulation(graph.nodes)
      .force('link', d3.forceLink(graph.links)
        .id(d => d.id)
        .distance(linkDistance)
        .strength(l => 0.15 + 0.85 * ((l.value - VMIN) / (VMAX - VMIN)))
      )
      .force('charge', d3.forceManyBody().strength(-320))
      .force('center', d3.forceCenter(w/2, h/2))
      .force('collide', d3.forceCollide().radius(d => nodeRadius(d) + 12).iterations(2))
      .velocityDecay(0.25)
      .on('tick', render);
  }

  // hover
  function hitTestNode(mx, my) {
    for (let i = graph.nodes.length - 1; i >= 0; i--) {
      const n = graph.nodes[i];
      const r = nodeRadius(n);
      const dx = mx - n.x, dy = my - n.y;
      if (dx*dx + dy*dy <= r*r) return n;
    }
    return null;
  }
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const [ux, uy] = unproject(e.clientX - rect.left, e.clientY - rect.top);
    const node = hitTestNode(ux, uy);
    if (node) {
      tooltip.style.display = 'block';
      tooltip.textContent = `@${node.handle} — mentions: ${node.mentions}`;
      tooltip.style.left = e.clientX + 'px';
      tooltip.style.top = e.clientY + 'px';
    } else {
      tooltip.style.display = 'none';
    }
  });

  // recompute
  function recomputeAndRender() {
    const minMentions = parseInt(minCountInput.value, 10) || 1;
    graph = buildGraph(minMentions);
    clearLabels();
    fitCanvas();
    updateLinkStats();
    startSim();
  }

  // init
  (async function init() {
    try {
      fitCanvas();
      d3.select(canvas)
        .call(d3.zoom()
          .scaleExtent([0.25, 6])
          .on('zoom', (event) => { zoomTransform = event.transform; render(); })
        )
        .on('dblclick.zoom', null);

      await loadSocial();
      recomputeAndRender();
    } catch (err) {
      console.error(err);
      errEl.textContent = String(err.message || err);
    }
  })();
})();
</script>


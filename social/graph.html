<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Quasi Social Graph (since 2025-09-22)</title>
<style>
  :root { --bg:#000; --fg:#fff; --muted:#aaa; }
  html,body { margin:0; height:100%; background:var(--bg); color:var(--fg);
    font-family:"Helvetica Neue", Helvetica, Arial, system-ui, -apple-system, sans-serif; }
  a { color:var(--fg); text-decoration:underline; }
  .wrap { display:grid; grid-template-rows:auto 1fr; height:100%; }
  header { padding:12px 16px; border-bottom:1px solid #222; display:flex; align-items:center; gap:14px; flex-wrap:wrap; }
  header h1 { font-size:16px; margin:0; letter-spacing:.2px; font-weight:600; }
  header .controls { display:flex; align-items:center; gap:12px; flex-wrap:wrap; color:var(--muted); }
  label { font-size:12px; } input[type="range"]{ width:180px; }
  .hint { font-size:12px; color:var(--muted); }
  #graph { position:relative; width:100%; height:calc(100vh - 60px); }
  canvas { display:block; width:100%; height:100%; background:#000; }
  .tooltip { position:fixed; pointer-events:none; background:#000; color:#fff; padding:6px 8px; border:1px solid #333; border-radius:8px; font-size:12px; white-space:nowrap; transform:translate(-50%,-140%); display:none; }
  .legend { position:absolute; left:12px; bottom:12px; font-size:12px; color:var(--muted); }
  .error { color:#f66; font-size:12px; margin-left:8px; }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Quasi Social Graph</h1>
    <div class="controls">
      <label>Min mentions: <span id="minCountLabel">1</span>
        <input id="minCount" type="range" min="1" max="10" value="1" step="1" />
      </label>
      <label>Since: <strong>2025-09-22</strong></label>
      <label>Decay: <code>1 − 0.01 × days_ago</code></label>
      <span class="hint">(Zoom: scroll, Pan: drag. Click labels to open Twitter.)</span>
      <span id="status" class="hint"></span>
      <span id="error" class="error"></span>
    </div>
  </header>
  <div id="graph">
    <canvas id="c"></canvas>
    <div id="tooltip" class="tooltip"></div>
    <div class="legend">White nodes/edges on black; font: Helvetica Neue.</div>
  </div>
</div>

<script>
(function () {
  // ==== DOM & Status ====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const tooltip = document.getElementById('tooltip');
  const statusEl = document.getElementById('status');
  const errEl = document.getElementById('error');
  const minCountInput = document.getElementById('minCount');
  const minCountLabel = document.getElementById('minCountLabel');

  function setStatus(s){ statusEl.textContent = s; }
  window.addEventListener('error', e => { errEl.textContent = String(e.error || e.message || e); });

  // Paint black immediately
  function fitCanvas() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const { clientWidth:w, clientHeight:h } = canvas.parentElement;
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  function paintBlack() {
    const { clientWidth:w, clientHeight:h } = canvas;
    ctx.save(); ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,w,h);
    ctx.restore();
  }
  window.addEventListener('resize', () => { fitCanvas(); render(); });

  // ==== Config & Helpers ====
  const SOCIAL_URL = '/social';
  const CUTOFF_ISO = '2025-09-22';
  const TW_HOSTS = new Set(['twitter.com','x.com','mobile.twitter.com']);

  function parseDateFromDataDate(val) {
    if (!val) return null;
    const s = String(val).trim();
    if (/^\d{6}$/.test(s)) { const mm=+s.slice(0,2), dd=+s.slice(2,4), yy=+s.slice(4,6); const d=new Date(2000+yy, mm-1, dd); return isNaN(d)?null:d; }
    if (/^\d{8}$/.test(s)) { const mm=+s.slice(0,2), dd=+s.slice(2,4), yyyy=+s.slice(4,8); const d=new Date(yyyy, mm-1, dd); return isNaN(d)?null:d; }
    return null;
  }
  function getCutoffDate(){ const [y,m,d]=CUTOFF_ISO.split('-').map(Number); return new Date(y,m-1,d); }
  function daysAgo(date){ return Math.max(0, Math.floor((Date.now()-date.getTime())/86400000)); }
  function extractHandleFromHref(href) {
    try {
      const u = new URL(href, location.origin);
      if (TW_HOSTS.has(u.hostname)) {
        const seg = u.pathname.split('/').filter(Boolean)[0] || '';
        return seg.replace(/^@/, '').trim();
      }
      return null;
    } catch { return null; }
  }

  // ==== Data ====
  let rawPosts = [];
  let graph = { nodes:[], links:[] };

  async function loadSocial() {
    setStatus('fetching /social…');
    const res = await fetch(SOCIAL_URL, { credentials:'same-origin' });
    if (!res.ok) throw new Error('Failed to fetch /social');
    const html = await res.text();
    const doc = new DOMParser().parseFromString(html, 'text/html');

    const cutoff = getCutoffDate();
    const ps = Array.from(doc.querySelectorAll('p[data-type="social"][data-date]'));
    setStatus(`found ${ps.length} social nodes`);

    const posts = [];
    ps.forEach(el => {
      const date = parseDateFromDataDate(el.getAttribute('data-date'));
      if (!date || date < cutoff) return;
      const handles = new Set();
      el.querySelectorAll('a[href]').forEach(a => {
        const h = extractHandleFromHref(a.getAttribute('href'));
        if (h) handles.add(h.toLowerCase());
      });
      if (handles.size >= 1) posts.push({ date, handles });
    });
    posts.sort((a,b)=>a.date-b.date);
    rawPosts = posts;
    setStatus(`parsed ${posts.length} posts since 2025-09-22`);
  }

  function buildGraph(minMentions=1) {
    const mentionCounts = new Map();
    rawPosts.forEach(p => p.handles.forEach(h => mentionCounts.set(h, (mentionCounts.get(h)||0)+1)));
    const eligible = new Set([...mentionCounts.entries()].filter(([,c])=>c>=minMentions).map(([h])=>h));

    const linkKey = (a,b)=>a<b?`${a}|${b}`:`${b}|${a}`;
    const linksMap = new Map();

    rawPosts.forEach(p => {
      const hs = [...p.handles].filter(h => eligible.has(h));
      if (hs.length < 2) return;
      const w = Math.max(0, 1 - 0.01*daysAgo(p.date));
      for (let i=0;i<hs.length;i++) for (let j=i+1;j<hs.length;j++) {
        const a=hs[i], b=hs[j], key=linkKey(a,b);
        const prev = linksMap.get(key) || { source:a, target:b, value:0, count:0 };
        prev.value += w; prev.count += 1; linksMap.set(key, prev);
      }
    });

    return {
      nodes: [...eligible].map(h=>({ id:h, handle:h, mentions: mentionCounts.get(h)||0 })),
      links: [...linksMap.values()]
    };
  }

  // ==== Vanilla force simulation + zoom/pan ====
  // Zoom/pan
  let zoom = 1, offsetX = 0, offsetY = 0;
  function screenToWorld(x,y){ return { x:(x - offsetX)/zoom, y:(y - offsetY)/zoom }; }
  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const scale = Math.exp(-e.deltaY * 0.0015);
    const rect = canvas.getBoundingClientRect();
    const cx = e.clientX - rect.left, cy = e.clientY - rect.top;
    const before = screenToWorld(cx, cy);
    zoom = Math.max(0.25, Math.min(6, zoom * scale));
    const after = screenToWorld(cx, cy);
    offsetX += (after.x - before.x) * zoom;
    offsetY += (after.y - before.y) * zoom;
    render();
  }, { passive:false });
  let panning=false, lastX=0, lastY=0;
  canvas.addEventListener('mousedown', e=>{ panning=true; lastX=e.clientX; lastY=e.clientY; });
  window.addEventListener('mouseup', ()=>{ panning=false; });
  window.addEventListener('mousemove', e=>{
    if (!panning) return;
    offsetX += (e.clientX - lastX);
    offsetY += (e.clientY - lastY);
    lastX = e.clientX; lastY = e.clientY;
    render();
  });

  // Force params + state
  let nodes=[], links=[];
  let animId = null;

  function layoutGraph() {
    // Init node positions on jittered grid
    const W = canvas.parentElement.clientWidth, H = canvas.parentElement.clientHeight;
    nodes.forEach((n,i)=>{
      const cols = Math.ceil(Math.sqrt(nodes.length));
      const x = (i % cols) / (cols - 1 || 1);
      const y = Math.floor(i / cols) / (cols - 1 || 1);
      n.x = 40 + x*(W-80) + (Math.random()-0.5)*24;
      n.y = 40 + y*(H-80) + (Math.random()-0.5)*24;
      n.vx = 0; n.vy = 0;
    });

    // Spring target length from weight (stronger -> shorter)
    const vals = links.map(l=>l.value||0);
    let vmin=0, vmax=1; if (vals.length){ vmin=Math.min(...vals); vmax=Math.max(...vals); if (vmax===vmin) vmax=vmin+1; }
    links.forEach(l=>{
      const t = ((l.value||0) - vmin) / (vmax - vmin);
      const dMin = 26, dMax = Math.max(140, 0.55*Math.min(W,H));
      l.len = dMax - t*(dMax - dMin);
      l.a = nodes.find(n=>n.id===l.source);
      l.b = nodes.find(n=>n.id===l.target);
    });

    // Run simulation
    let steps = 0;
    function step() {
      steps++;
      const kSpring = 0.01;         // spring constant
      const kRepel = 2500;          // repulsion strength
      const centerK = 0.0005;       // gentle centering
      const friction = 0.85;        // velocity damping

      // Repulsion
      for (let i=0;i<nodes.length;i++){
        for (let j=i+1;j<nodes.length;j++){
          const a=nodes[i], b=nodes[j];
          let dx=b.x-a.x, dy=b.y-a.y, d2=dx*dx+dy*dy;
          if (d2===0){ dx=(Math.random()-0.5)*1e-3; dy=(Math.random()-0.5)*1e-3; d2=dx*dx+dy*dy; }
          const f = kRepel / d2;
          const dist = Math.sqrt(d2);
          const fx = f * dx/dist, fy = f * dy/dist;
          a.vx -= fx; a.vy -= fy; b.vx += fx; b.vy += fy;
        }
      }

      // Springs
      for (const l of links){
        const a=l.a, b=l.b; if (!a||!b) continue;
        let dx=b.x-a.x, dy=b.y-a.y;
        let dist = Math.sqrt(dx*dx+dy*dy) || 1e-6;
        const diff = dist - l.len;
        const f = kSpring * diff;
        const fx = f * dx/dist, fy = f * dy/dist;
        a.vx += fx; a.vy += fy; b.vx -= fx; b.vy -= fy;
      }

      // Centering + integrate
      const cx = W/2, cy = H/2;
      let kinetic = 0;
      for (const n of nodes){
        n.vx += (cx - n.x)*centerK;
        n.vy += (cy - n.y)*centerK;
        n.vx *= friction; n.vy *= friction;
        n.x += n.vx; n.y += n.vy;
        kinetic += n.vx*n.vx + n.vy*n.vy;
      }

      render();

      if (steps < 800 && kinetic > 0.01) {
        animId = requestAnimationFrame(step);
      } else {
        setStatus(`layout settled in ${steps} steps`);
        animId = null;
      }
    }
    if (animId) cancelAnimationFrame(animId);
    animId = requestAnimationFrame(step);
  }

  // ==== Render ====
  function nodeRadius(n){ return 4 + Math.min(14, (n.mentions||0) * 1.2); }
  const labels = new Map();
  function render() {
    const { clientWidth:w, clientHeight:h } = canvas;
    // Black background
    ctx.save(); ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,w,h); ctx.restore();

    // World->screen transform
    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(zoom, zoom);

    // Edges (thin, constant)
    ctx.globalAlpha = 0.9;
    ctx.strokeStyle = '#ffffff';
    for (const l of links){
      const a=l.a, b=l.b; if (!a||!b) continue;
      ctx.beginPath(); ctx.lineWidth = 0.4;
      ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
    }

    // Nodes (hollow)
    for (const n of nodes){
      ctx.beginPath();
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 1.2 / Math.max(1, zoom*0.9);
      ctx.arc(n.x, n.y, nodeRadius(n), 0, Math.PI*2);
      ctx.stroke();
    }

    ctx.restore();

    // Labels in screen space
    for (const n of nodes){
      let el = labels.get(n.id);
      if (!el) {
        el = document.createElement('a');
        el.href = `https://twitter.com/${n.handle}`;
        el.target = '_blank'; el.rel = 'noopener';
        el.style.position = 'absolute';
        el.style.color = '#fff';
        el.style.textDecoration = 'none';
        el.style.fontSize = '12px';
        el.style.padding = '2px 3px';
        el.style.borderRadius = '6px';
        el.textContent = '@' + n.handle;
        canvas.parentElement.appendChild(el);
        labels.set(n.id, el);
      }
      const r = nodeRadius(n);
      const sx = offsetX + n.x*zoom;
      const sy = offsetY + n.y*zoom;
      const rect = el.getBoundingClientRect();
      el.style.left = (sx - rect.width/2) + 'px';
      el.style.top  = (sy - r*zoom - rect.height - 4) + 'px';
    }
  }
  function clearLabels(){ labels.forEach(el=>el.remove()); labels.clear(); }

  // Tooltip
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left - offsetX) / zoom;
    const y = (e.clientY - rect.top  - offsetY) / zoom;
    let hit = null;
    for (let i=nodes.length-1;i>=0;i--){
      const n = nodes[i], r=nodeRadius(n);
      const dx=x-n.x, dy=y-n.y;
      if (dx*dx+dy*dy <= r*r) { hit = n; break; }
    }
    if (hit) {
      tooltip.style.display='block';
      tooltip.textContent = `@${hit.handle} — mentions: ${hit.mentions}`;
      tooltip.style.left = e.clientX + 'px';
      tooltip.style.top  = e.clientY + 'px';
    } else {
      tooltip.style.display='none';
    }
  });

  // ==== Recompute ====
  function recomputeAndRender() {
    const minMentions = parseInt(minCountInput.value, 10) || 1;
    graph = buildGraph(minMentions);
    nodes = graph.nodes;
    links = graph.links.map(l => ({...l})); // copy for refs
    // attach refs after nodes set
    links.forEach(l => { l.a = nodes.find(n=>n.id===l.source); l.b = nodes.find(n=>n.id===l.target); });
    clearLabels();
    fitCanvas();
    paintBlack();
    if (!nodes.length) { setStatus('no eligible nodes with current filter'); render(); return; }
    setStatus(`nodes: ${nodes.length} | links: ${links.length}`);
    layoutGraph();
  }

  // ==== Init ====
  (async function init(){
    try {
      setStatus('boot…');
      fitCanvas(); paintBlack();
      minCountLabel.textContent = minCountInput.value;
      await loadSocial();
      recomputeAndRender();
    } catch (err) {
      console.error(err);
      errEl.textContent = String(err.message || err);
    }
  })();

  // UI change
  minCountInput.addEventListener('input', () => {
    minCountLabel.textContent = minCountInput.value;
    recomputeAndRender();
  });
})();
</script>
</body>
</html>

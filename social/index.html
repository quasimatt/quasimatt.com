<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>social graph - quasimatt</title>
    <link rel="stylesheet" href="social.css">
    <link rel="icon" href="https://pbs.twimg.com/profile_images/1614420813800767490/mf6sQbCT_400x400.jpg" type="image/png">
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1><a href="/" target="_self">quasimatt</a> / social graph</h1>
        </header>
        
        <div class="controls">
            <label>
                minimum mentions:
                <input type="number" id="minMentions" value="2" min="1" max="20">
            </label>
            <label>
                decay per day:
                <input type="number" id="decayRate" value="0.01" min="0" max="0.1" step="0.001">
            </label>
            <button id="refresh">refresh</button>
        </div>
        
        <div id="graph"></div>
        
        <div class="info">
            <p>nodes represent people, edges represent co-occurrences in posts.</p>
            <p>edge weights decay over time based on post recency.</p>
            <p>click on a node to see the twitter profile.</p>
        </div>
    </div>

    <script>
        // Configuration
        const SINCE_DATE = new Date('2025-09-22');
        const WIDTH = Math.min(window.innerWidth - 40, 1200);
        const HEIGHT = Math.min(window.innerHeight - 200, 800);

        // Global state
        let postsData = [];
        let minMentions = 2;
        let decayRate = 0.01;

        // Load and process data
        async function loadData() {
            try {
                const response = await fetch('/social/posts.json');
                if (!response.ok) throw new Error('Failed to load posts.json');
                postsData = await response.json();
                
                // Filter posts by date
                postsData = postsData.filter(post => new Date(post.date) >= SINCE_DATE);
                
                renderGraph();
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('graph').innerHTML = 
                    '<p style="color: white; padding: 20px;">error loading posts.json</p>';
            }
        }

        // Calculate mention counts and co-occurrence scores
        function processData() {
            const mentionCounts = {};
            const coOccurrences = {};
            const now = new Date();

            // Count mentions
            postsData.forEach(post => {
                const postDate = new Date(post.date);
                const daysAgo = (now - postDate) / (1000 * 60 * 60 * 24);
                const decay = Math.exp(-decayRate * daysAgo);

                post.handles.forEach(handle => {
                    mentionCounts[handle] = (mentionCounts[handle] || 0) + 1;
                });

                // Calculate co-occurrences with decay
                for (let i = 0; i < post.handles.length; i++) {
                    for (let j = i + 1; j < post.handles.length; j++) {
                        const pair = [post.handles[i], post.handles[j]].sort().join('|');
                        coOccurrences[pair] = (coOccurrences[pair] || 0) + decay;
                    }
                }
            });

            // Filter by minimum mentions
            const validHandles = Object.keys(mentionCounts)
                .filter(handle => mentionCounts[handle] >= minMentions);

            // Build nodes
            const nodes = validHandles.map(handle => ({
                id: handle,
                count: mentionCounts[handle]
            }));

            // Build edges
            const edges = [];
            const validHandleSet = new Set(validHandles);
            
            Object.entries(coOccurrences).forEach(([pair, weight]) => {
                const [source, target] = pair.split('|');
                if (validHandleSet.has(source) && validHandleSet.has(target)) {
                    edges.push({ source, target, weight });
                }
            });

            return { nodes, edges };
        }

        // Render the graph
        function renderGraph() {
            const { nodes, edges } = processData();

            if (nodes.length === 0) {
                document.getElementById('graph').innerHTML = 
                    '<p style="color: white; padding: 20px;">no data matches the current filters</p>';
                return;
            }

            // Clear previous graph
            d3.select('#graph').selectAll('*').remove();

            // Create SVG
            const svg = d3.select('#graph')
                .append('svg')
                .attr('width', WIDTH)
                .attr('height', HEIGHT);

            // Define arrow marker
            svg.append('defs').append('marker')
                .attr('id', 'arrowhead')
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', 20)
                .attr('refY', 0)
                .attr('orient', 'auto')
                .attr('markerWidth', 6)
                .attr('markerHeight', 6)
                .append('path')
                .attr('d', 'M0,-5L10,0L0,5')
                .attr('fill', '#666');

            // Create force simulation
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(edges)
                    .id(d => d.id)
                    .distance(d => 100 / Math.sqrt(d.weight))
                    .strength(d => Math.min(d.weight / 10, 1)))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(WIDTH / 2, HEIGHT / 2))
                .force('collision', d3.forceCollide().radius(30));

            // Draw edges
            const link = svg.append('g')
                .selectAll('line')
                .data(edges)
                .enter()
                .append('line')
                .attr('stroke', '#666')
                .attr('stroke-width', d => Math.sqrt(d.weight) * 2)
                .attr('stroke-opacity', 0.6);

            // Draw nodes
            const node = svg.append('g')
                .selectAll('g')
                .data(nodes)
                .enter()
                .append('g')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            node.append('circle')
                .attr('r', d => 5 + Math.sqrt(d.count) * 3)
                .attr('fill', '#fff')
                .attr('stroke', '#000')
                .attr('stroke-width', 2)
                .style('cursor', 'pointer');

            // Add labels
            node.append('text')
                .text(d => d.id)
                .attr('x', 0)
                .attr('y', -15)
                .attr('text-anchor', 'middle')
                .attr('fill', '#fff')
                .attr('font-size', '12px')
                .attr('font-family', "'Helvetica Neue', sans-serif")
                .style('pointer-events', 'none');

            // Click handler to open Twitter profile
            node.on('click', (event, d) => {
                const handle = d.id.replace('@', '');
                window.open(`https://twitter.com/${handle}`, '_blank');
            });

            // Update positions on each tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('transform', d => `translate(${d.x},${d.y})`);
            });

            // Drag functions
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }

        // Event listeners
        document.getElementById('refresh').addEventListener('click', () => {
            minMentions = parseInt(document.getElementById('minMentions').value);
            decayRate = parseFloat(document.getElementById('decayRate').value);
            renderGraph();
        });

        // Handle window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                location.reload();
            }, 500);
        });

        // Initialize
        loadData();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="icon" href="https://pbs.twimg.com/profile_images/1614420813800767490/mf6sQbCT_400x400.jpg" type="image/png">
<title>quasimatt.com social graph</title>

<style>
  :root { --bg:#000; --fg:#fff; --muted:#aaa; }
  html,body {
    margin:0; height:100%; background:var(--bg); color:var(--fg);
    font-family:"Helvetica Neue", Helvetica, Arial, system-ui, -apple-system, sans-serif;
  }
  a { color:var(--fg); text-decoration:underline; }
  .wrap { display:grid; grid-template-rows:auto 1fr; height:100%; }

  header {
    padding:12px 16px; border-bottom:1px solid #222;
    display:flex; align-items:center; gap:14px; flex-wrap:wrap;
    position:sticky; top:0; z-index:1000; background:#000;
  }
  header h1 { font-size:16px; margin:0; letter-spacing:.2px; font-weight:600; }
  header .controls { display:flex; align-items:center; gap:12px; flex-wrap:wrap; color:var(--muted); }
  label { font-size:12px; }

  .hint { font-size:12px; color:var(--muted); }

  #graph { position:relative; width:100%; height:calc(100vh - 60px); overflow:hidden; touch-action:none; }
  canvas { display:block; width:100%; height:100%; background:#000; }

  .tooltip {
    position:fixed; pointer-events:none; background:#000; color:#fff;
    padding:6px 8px; border:1px solid #333; border-radius:8px;
    font-size:12px; white-space:nowrap; transform:translate(-50%,-140%);
    display:none; z-index:999999;
  }

  .error { color:#f66; font-size:12px; margin-left:8px; }

  /* ============================ */
  /* Dual-handle mentions slider  */
  /* ============================ */

  .mentions-control {
    display:flex;
    flex-direction:column;
    gap:4px;
  }
  .mentions-control span {
    font-size:12px;
  }
  .mentions-range {
    position:relative;
    width:180px;
    height:24px;
  }
  .mentions-bar {
    position:absolute;
    left:0; right:0;
    top:50%; transform:translateY(-50%);
    height:6px; background:#333; border-radius:3px;
  }

  .mentions-range input[type="range"] {
    position:absolute; left:0; top:0;
    width:100%; height:24px;
    background:transparent;
    pointer-events:none;
    appearance:none;
    -webkit-appearance:none;
  }

  /* Thumbs — WebKit */
  .mentions-range input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance:none;
    appearance:none;
    pointer-events:auto;
    height:14px; width:14px;
    background:#fff; border:1px solid #999; border-radius:50%;
    margin-top:0;
  }
  .mentions-range input[type="range"]::-webkit-slider-runnable-track {
    height:24px; background:transparent;
  }

  /* Thumbs — Firefox */
  .mentions-range input[type="range"]::-moz-range-thumb {
    pointer-events:auto;
    height:14px; width:14px;
    background:#fff; border:1px solid #999; border-radius:50%;
  }
  .mentions-range input[type="range"]::-moz-range-track {
    height:24px; background:transparent;
  }

  #minMentions { z-index:2; }
  #maxMentions { z-index:3; }

</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1><a href="https://quasimatt.com/social">quasimatt.com/social</a>/graph</h1>

    <div class="controls">
      <!-- label toggle -->
      <label>
        <input type="checkbox" id="toggleLabels" checked>
        labels
      </label>

      <label>
        <input type="checkbox" id="showEdges" checked>
        edges
      </label>

      <!-- new mentions dual slider -->
      <div class="mentions-control">
        <span>mentions: <span id="mentionMinLabel"></span> – <span id="mentionMaxLabel"></span></span>
        <div class="mentions-range">
          <div class="mentions-bar"></div>
          <input id="minMentions" type="range" min="1" max="10" value="1">
          <input id="maxMentions" type="range" min="1" max="10" value="10">
        </div>
      </div>

      <label>since: <strong>2025-09-22</strong></label>
      <span class="hint">(zoom: scroll, pan: drag)</span>
      <span id="status" class="hint"></span>
      <span id="error" class="error"></span>
    </div>
  </header>

  <div id="graph">
    <canvas id="c"></canvas>
    <div id="tooltip" class="tooltip"></div>
  </div>
</div>

<script>
(function () {

  /* ===== DOM ===== */

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const tooltip = document.getElementById('tooltip');
  const statusEl = document.getElementById('status');
  const errEl = document.getElementById('error');

  const showEdgesInput = document.getElementById('showEdges');
  const toggleLabelsInput = document.getElementById('toggleLabels');

  const minMentionsInput = document.getElementById('minMentions');
  const maxMentionsInput = document.getElementById('maxMentions');
  const mentionMinLabel = document.getElementById('mentionMinLabel');
  const mentionMaxLabel = document.getElementById('mentionMaxLabel');

  let showEdges = true;
  let showLabels = true;

  showEdgesInput.addEventListener('change', () => { showEdges = showEdgesInput.checked; render(); });
  toggleLabelsInput.addEventListener('change', () => { showLabels = toggleLabelsInput.checked; render(); });

  // prevent page scroll
  ['wheel','touchmove'].forEach(evt => {
    document.getElementById('graph').addEventListener(evt, e => e.preventDefault(), { passive:false });
  });

  function setStatus(s){ statusEl.textContent = s; }

  window.addEventListener('error', e => {
    errEl.textContent = String(e.error || e.message || e);
  });

  /* ===== Canvas retina fix ===== */

  function fitCanvas() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const { clientWidth:w, clientHeight:h } = canvas.parentElement;
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = w + "px";
    canvas.style.height = h + "px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  function clearBlack() {
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.restore();
  }

  window.addEventListener('resize', () => { fitCanvas(); render(); });

  /* ===== Social parsing ===== */

  const SOCIAL_URL = "/social";
  const CUTOFF_ISO = "2025-09-22";

  const TW_HOSTS = new Set(["twitter.com","x.com","mobile.twitter.com"]);
  const IG_HOSTS = new Set(["instagram.com","www.instagram.com","m.instagram.com"]);
  const IG_DISALLOWED_FIRST = new Set(["p","reel","reels","stories","explore","tv","accounts"]);

  function parseDateFromDataDate(v){
    if (!v) return null;
    const s = String(v).trim();
    if (/^\d{6}$/.test(s)) {
      return new Date(2000+Number(s.slice(4)), Number(s.slice(0,2))-1, Number(s.slice(2,4)));
    }
    if (/^\d{8}$/.test(s)) {
      return new Date(Number(s.slice(4,8)), Number(s.slice(0,2))-1, Number(s.slice(2,4)));
    }
    return null;
  }

  function getCutoffDate() {
    const [y,m,d] = CUTOFF_ISO.split("-").map(Number);
    return new Date(y,m-1,d);
  }

  function extractAccountFromHref(href){
    try {
      const u = new URL(href, location.origin);
      const host = u.hostname.toLowerCase();

      if (TW_HOSTS.has(host)) {
        const seg = u.pathname.split('/').filter(Boolean)[0] || "";
        const handle = seg.replace(/^@/,"").trim().toLowerCase();
        if (!handle) return null;
        return { id:`x:${handle}`, platform:'x', handle, url:`https://twitter.com/${handle}` };
      }

      if (IG_HOSTS.has(host)) {
        const parts = u.pathname.split('/').filter(Boolean);
        const first = (parts[0]||"").toLowerCase();
        if (!first || IG_DISALLOWED_FIRST.has(first)) return null;
        if (!/^[a-z0-9._]{1,30}$/i.test(first)) return null;
        const handle = first.toLowerCase();
        return { id:`ig:${handle}`, platform:'ig', handle, url:`https://instagram.com/${handle}` };
      }

      return null;
    } catch {
      return null;
    }
  }

  let rawPosts = [];
  const accountMeta = new Map();

  async function loadSocial(){
    setStatus("fetching /social…");
    const res = await fetch(SOCIAL_URL, { credentials:"same-origin" });
    if (!res.ok) throw new Error("Failed to fetch /social");

    const html = await res.text();
    const doc = new DOMParser().parseFromString(html, "text/html");

    const cutoff = getCutoffDate();
    const ps = Array.from(doc.querySelectorAll('p[data-type="social"][data-date]'));

    const posts = [];
    ps.forEach(el => {
      const d = parseDateFromDataDate(el.getAttribute('data-date'));
      if (!d || d < cutoff) return;

      const ids = new Set();
      el.querySelectorAll("a[href]").forEach(a => {
        const acc = extractAccountFromHref(a.getAttribute("href"));
        if (acc) {
          ids.add(acc.id);
          if (!accountMeta.has(acc.id)) {
            accountMeta.set(acc.id, { platform:acc.platform, handle:acc.handle, url:acc.url });
          }
        }
      });

      if (ids.size >= 1) posts.push({ date:d, ids });
    });

    posts.sort((a,b)=>a.date-b.date);
    rawPosts = posts;

    setStatus(`parsed ${posts.length} posts`);
  }

  /* ===== Graph build (no decay) ===== */

  function buildGraph(minM, maxM){
    const rawCounts = new Map();
    const linkKey = (a,b) => a<b ? `${a}|${b}` : `${b}|${a}`;
    const linksMap = new Map();

    for (const p of rawPosts){
      const ids = [...p.ids];

      for (const id of ids) {
        rawCounts.set(id, (rawCounts.get(id)||0) + 1);
      }

      if (ids.length >= 2){
        for (let i=0;i<ids.length;i++){
          for (let j=i+1;j<ids.length;j++){
            const a = ids[i], b = ids[j];
            const key = linkKey(a,b);
            const prev = linksMap.get(key) || {source:a, target:b, co:0};
            prev.co += 1;
            linksMap.set(key, prev);
          }
        }
      }
    }

    const eligible = new Set(
      [...rawCounts.entries()]
      .filter(([id,c]) => c >= minM && c <= maxM)
      .map(([id]) => id)
    );

    const links = [];
    for (const {source,target,co} of linksMap.values()){
      if (!eligible.has(source) || !eligible.has(target)) continue;
      if (co > 0) links.push({ source, target, value:co });
    }

    const nodes = [...eligible].map(id => {
      const m = accountMeta.get(id) ||
        { platform:"x", handle:id.split(':').pop(), url:"" };
      return {
        id,
        platform:m.platform,
        handle:m.handle,
        url:m.url,
        mentions: rawCounts.get(id) || 0
      };
    });

    return { nodes, links };
  }

  /* ===== Layout state ===== */

  let nodes=[], links=[];
  let neighbors=new Map();
  let globalMaxMentions=1;

  let zoom=1, offsetX=0, offsetY=0;

  function screenToWorld(x,y){
    return { x:(x-offsetX)/zoom, y:(y-offsetY)/zoom };
  }

  canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const cx = e.clientX - rect.left;
    const cy = e.clientY - rect.top;
    const before = screenToWorld(cx,cy);

    const scale = Math.exp(-e.deltaY * 0.0012);
    zoom = Math.min(6, Math.max(0.25, zoom * scale));

    const after = screenToWorld(cx,cy);
    offsetX += (after.x-before.x)*zoom;
    offsetY += (after.y-before.y)*zoom;

    render();
  }, { passive:false });

  let isPanning=false, lastX=0, lastY=0;
  canvas.addEventListener('mousedown', e => {
    isPanning=true; lastX=e.clientX; lastY=e.clientY;
  });
  window.addEventListener('mouseup', () => isPanning=false);
  window.addEventListener('mousemove', e => {
    if (!isPanning) return;
    offsetX += (e.clientX-lastX);
    offsetY += (e.clientY-lastY);
    lastX=e.clientX; lastY=e.clientY;
    render();
  });

  /* ===== Node radius: fully relative ===== */

  function nodeRadius(n){
    const minR=4, maxR=18;
    const m = n.mentions || 0;
    const M = globalMaxMentions || 1;
    return minR + (maxR-minR)*(m/M);
  }

  /* ===== Force layout ===== */

  let animId=null;
  const labels = new Map();

  function layoutGraph(){
    const W = canvas.parentElement.clientWidth;
    const H = canvas.parentElement.clientHeight;

    nodes.forEach((n,i)=>{
      const cols = Math.ceil(Math.sqrt(nodes.length));
      const x = (i % cols) / (cols-1 || 1);
      const y = Math.floor(i/cols) / (cols-1 || 1);
      n.x = 40 + x*(W-80) + (Math.random()-0.5)*24;
      n.y = 40 + y*(H-80) + (Math.random()-0.5)*24;
      n.vx=0; n.vy=0;
    });

    neighbors = new Map();
    nodes.forEach(n=>neighbors.set(n.id,new Set()));
    links.forEach(l=>{
      const a = nodes.find(n=>n.id===l.source);
      const b = nodes.find(n=>n.id===l.target);
      if (!a||!b) return;
      l.a=a; l.b=b;
      neighbors.get(a.id).add(b.id);
      neighbors.get(b.id).add(a.id);
    });

    links.forEach(l => {
      l.len = 140 - Math.min(110, l.value*4);
      if (l.len < 26) l.len = 26;
    });

    let steps=0;

    function step(){
      steps++;

      const kSpring=0.006;
      const centerK=0.0005;
      const friction=0.76;

      const repelNear=300;
      const repelFar=2500;

      for (let i=0;i<nodes.length;i++){
        for (let j=i+1;j<nodes.length;j++){
          const a=nodes[i], b=nodes[j];
          let dx=b.x-a.x, dy=b.y-a.y;
          let dist2=dx*dx+dy*dy;
          if (dist2===0){
            dx=(Math.random()-0.5)*1e-3;
            dy=(Math.random()-0.5)*1e-3;
            dist2=dx*dx+dy*dy;
          }
          const dist=Math.sqrt(dist2);

          const areNeighbors = neighbors.get(a.id).has(b.id);
          const kRepel = areNeighbors ? repelNear : repelFar;
          const f = kRepel/dist2;

          const fx = f*(dx/dist), fy=f*(dy/dist);
          a.vx -= fx; a.vy -= fy;
          b.vx += fx; b.vy += fy;

          const minDist = nodeRadius(a)+nodeRadius(b)+6;
          if (dist < minDist){
            const overlap = (minDist-dist);
            const push = 0.25*overlap;
            const pfx = push*(dx/dist), pfy=push*(dy/dist);
            a.vx -= pfx; a.vy -= pfy;
            b.vx += pfx; b.vy += pfy;
          }
        }
      }

      links.forEach(l=>{
        const a=l.a, b=l.b;
        if (!a||!b) return;
        let dx=b.x-a.x, dy=b.y-a.y;
        let dist = Math.sqrt(dx*dx+dy*dy)||1e-6;
        const diff = dist-l.len;
        const f=kSpring*diff;
        const fx=f*(dx/dist), fy=f*(dy/dist);
        a.vx += fx; a.vy += fy;
        b.vx -= fx; b.vy -= fy;
      });

      const cx=W/2, cy=H/2;
      let kinetic=0;
      nodes.forEach(n=>{
        n.vx += (cx-n.x)*centerK;
        n.vy += (cy-n.y)*centerK;
        n.vx*=friction; n.vy*=friction;
        n.x+=n.vx; n.y+=n.vy;
        kinetic += n.vx*n.vx + n.vy*n.vy;
      });

      render();

      if (steps<2000 && kinetic>0.01) animId=requestAnimationFrame(step);
      else {
        setStatus(`layout settled in ${steps} steps`);
        animId=null;
      }
    }

    if (animId) cancelAnimationFrame(animId);
    animId=requestAnimationFrame(step);
  }

  /* ===== render ===== */

  function clearLabels(){
    labels.forEach(el=>el.remove());
    labels.clear();
  }

  function render(){
    clearBlack();

    // edges
    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(zoom, zoom);

    if (showEdges){
      ctx.globalAlpha=0.9;
      ctx.strokeStyle="#fff";
      links.forEach(l=>{
        const a=l.a, b=l.b;
        if (!a||!b) return;
        ctx.beginPath();
        ctx.lineWidth=0.4;
        ctx.moveTo(a.x,a.y);
        ctx.lineTo(b.x,b.y);
        ctx.stroke();
      });
    }

    // nodes
    nodes.forEach(n=>{
      ctx.beginPath();
      ctx.strokeStyle="#fff";
      ctx.lineWidth=1.2/(Math.max(1,zoom*0.9));
      ctx.arc(n.x,n.y,nodeRadius(n),0,Math.PI*2);
      ctx.stroke();
    });

    ctx.restore();

    // labels
    if (showLabels){
      nodes.forEach(n=>{
        let el=labels.get(n.id);
        if (!el){
          el=document.createElement('a');
          el.href = n.url || "";
          el.target="_blank"; el.rel="noopener";
          el.style.position="absolute";
          el.style.color="#fff";
          el.style.textDecoration="none";
          el.style.fontSize="12px";
          el.style.padding="2px 3px";
          el.style.borderRadius="6px";
          el.textContent=`@${n.handle}`;
          canvas.parentElement.appendChild(el);
          labels.set(n.id,el);
        } else {
          el.href=n.url;
          el.textContent=`@${n.handle}`;
        }

        const r=nodeRadius(n);
        const sx=offsetX+n.x*zoom;
        const sy=offsetY+n.y*zoom;
        const rect=el.getBoundingClientRect();
        el.style.left=(sx-rect.width/2)+"px";
        el.style.top=(sy-r*zoom-rect.height-4)+"px";
      });
    } else {
      clearLabels();
    }
  }

  /* ===== tooltip ===== */

  canvas.addEventListener('mousemove', e=>{
    const rect=canvas.getBoundingClientRect();
    const x=(e.clientX-rect.left-offsetX)/zoom;
    const y=(e.clientY-rect.top-offsetY)/zoom;

    let hit=null;
    for (let i=nodes.length-1;i>=0;i--){
      const n=nodes[i], r=nodeRadius(n);
      const dx=x-n.x, dy=y-n.y;
      if (dx*dx+dy*dy <= r*r){ hit=n; break; }
    }

    if (hit){
      const connCount = neighbors.get(hit.id).size;
      tooltip.textContent = `@${hit.handle} — mentions: ${hit.mentions} — connections: ${connCount}`;
      tooltip.style.display="block";
      tooltip.style.left=e.clientX+"px";
      tooltip.style.top=e.clientY+"px";
    } else {
      tooltip.style.display="none";
    }
  });

  /* ===== recompute ===== */

  function recompute(){
    const mentionTotals=new Map();
    rawPosts.forEach(p=>{
      p.ids.forEach(id=>{
        mentionTotals.set(id, (mentionTotals.get(id)||0)+1);
      });
    });

    const vals=[...mentionTotals.values()];
    const maxMentions = vals.length ? Math.max(...vals) : 1;
    globalMaxMentions=maxMentions;

    // enforce slider consistency
    if (+maxMentionsInput.value > maxMentions) maxMentionsInput.value=maxMentions;
    if (+minMentionsInput.value > +maxMentionsInput.value) minMentionsInput.value=maxMentionsInput.value;

    mentionMinLabel.textContent = minMentionsInput.value;
    mentionMaxLabel.textContent = maxMentionsInput.value;

    const graph = buildGraph(+minMentionsInput.value, +maxMentionsInput.value);
    nodes=graph.nodes;
    links=graph.links;

    clearLabels();
    fitCanvas();
    clearBlack();

    if (!nodes.length){
      setStatus("no nodes in selected range");
      render();
      return;
    }

    setStatus(`nodes: ${nodes.length} | edges: ${links.length}`);
    layoutGraph();
  }

  minMentionsInput.addEventListener('input', ()=>{
    if (+minMentionsInput.value > +maxMentionsInput.value){
      maxMentionsInput.value=minMentionsInput.value;
    }
    recompute();
  });

  maxMentionsInput.addEventListener('input', ()=>{
    if (+maxMentionsInput.value < +minMentionsInput.value){
      minMentionsInput.value=maxMentionsInput.value;
    }
    recompute();
  });

  /* ===== init ===== */

  (async function init(){
    try {
      setStatus("boot…");
      fitCanvas(); clearBlack();
      await loadSocial();
      recompute();
    } catch (err){
      errEl.textContent = String(err.message || err);
    }
  })();

})();
</script>
</body>
</html>


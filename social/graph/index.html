<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="icon" href="https://pbs.twimg.com/profile_images/1614420813800767490/mf6sQbCT_400x400.jpg" type="image/png">
<title>quasimatt.com social graph</title>
<style>
  :root { --bg:#000; --fg:#fff; --muted:#aaa; }
  html,body { margin:0; height:100%; background:var(--bg); color:var(--fg);
    font-family:"Helvetica Neue", Helvetica, Arial, system-ui, -apple-system, sans-serif; }
  a { color:var(--fg); text-decoration:underline; }
  .wrap { display:grid; grid-template-rows:auto 1fr; height:100%; }
  header { padding:12px 16px; border-bottom:1px solid #222; display:flex; align-items:center; gap:14px; flex-wrap:wrap; position: sticky; top: 0; z-index: 1000; background: #000; }
  header h1 { font-size:16px; margin:0; letter-spacing:.2px; font-weight:600; }
  header .controls { display:flex; align-items:center; gap:12px; flex-wrap:wrap; color:var(--muted); }
  label { font-size:12px; } input[type="range"]{ width:180px; }
  .hint { font-size:12px; color:var(--muted); }
  #graph { position:relative; width:100%; height:calc(100vh - 60px); overflow: hidden; touch-action: none; }
  canvas { display:block; width:100%; height:100%; background:#000; }
  .tooltip { position:fixed; pointer-events:none; background:#000; color:#fff; padding:6px 8px; border:1px solid #333; border-radius:8px; font-size:12px; white-space:nowrap; transform:translate(-50%,-140%); display:none; z-index: 999999;}
  .legend { position:absolute; left:12px; bottom:12px; font-size:12px; color:var(--muted); }
  .error { color:#f66; font-size:12px; margin-left:8px; }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1><a href="https://quasimatt.com">quasimatt.com</a> social graph</h1>
    <div class="controls">
      <label>min mentions: <span id="minCountLabel">1</span>
        <input id="minCount" type="range" min="1" max="10" value="3" step="1" />
      </label>
      <label>
        <input type="checkbox" id="showEdges" checked>
        show edges
      </label>
      <label>since: <strong>2025-09-22</strong></label>
      <span class="hint">(zoom: scroll, pan: drag. on desktop, click labels to open X.)</span>
      <span id="status" class="hint"></span>
      <span id="error" class="error"></span>
    </div>
  </header>
  <div id="graph">
    <canvas id="c"></canvas>
    <div id="tooltip" class="tooltip"></div>
  </div>
</div>

<script>
(function () {
  // ===== DOM =====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const tooltip = document.getElementById('tooltip');
  const statusEl = document.getElementById('status');
  const errEl = document.getElementById('error');
  const minCountInput = document.getElementById('minCount');
  const minCountLabel = document.getElementById('minCountLabel');
  const graphEl = document.getElementById('graph');

  const showEdgesInput = document.getElementById('showEdges');
  let showEdges = true;

  showEdgesInput.addEventListener('change', () => {
    showEdges = showEdgesInput.checked;
    render();
  });

  // Trap wheel / touchmove so the page doesn't scroll when interacting with the graph
  ['wheel','touchmove'].forEach(evt => {
    graphEl.addEventListener(evt, e => e.preventDefault(), { passive: false });
  });

  function setStatus(s){ statusEl.textContent = s; }
  window.addEventListener('error', e => { errEl.textContent = String(e.error || e.message || e); });

  // ===== Canvas (retina-safe) =====
  function fitCanvas() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const { clientWidth:w, clientHeight:h } = canvas.parentElement;
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  function clearBlack() {
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
  }
  window.addEventListener('resize', () => { fitCanvas(); render(); });

  // ===== Config & helpers =====
  const SOCIAL_URL = '/social';
  const CUTOFF_ISO = '2025-09-22';
  const TW_HOSTS = new Set(['twitter.com','x.com','mobile.twitter.com']);

  function parseDateFromDataDate(val) {
    if (!val) return null;
    const s = String(val).trim();
    if (/^\d{6}$/.test(s)) { const mm=+s.slice(0,2), dd=+s.slice(2,4), yy=+s.slice(4,6); const d=new Date(2000+yy, mm-1, dd); return isNaN(d)?null:d; }
    if (/^\d{8}$/.test(s)) { const mm=+s.slice(0,2), dd=+s.slice(2,4), yyyy=+s.slice(4,8); const d=new Date(yyyy, mm-1, dd); return isNaN(d)?null:d; }
    return null;
  }
  function getCutoffDate(){ const [y,m,d]=CUTOFF_ISO.split('-').map(Number); return new Date(y,m-1,d); }
  function daysAgo(date){ return Math.max(0, Math.floor((Date.now()-date.getTime())/86400000)); }
  function extractHandleFromHref(href) {
    try {
      const u = new URL(href, location.origin);
      if (TW_HOSTS.has(u.hostname)) {
        const seg = u.pathname.split('/').filter(Boolean)[0] || '';
        return seg.replace(/^@/, '').trim();
      }
      return null;
    } catch { return null; }
  }

  // ===== Data =====
  let rawPosts = [];
  let graph = { nodes:[], links:[] };

  async function loadSocial() {
    setStatus('fetching /social…');
    const res = await fetch(SOCIAL_URL, { credentials:'same-origin' });
    if (!res.ok) throw new Error('Failed to fetch /social');
    const html = await res.text();
    const doc = new DOMParser().parseFromString(html, 'text/html');

    const cutoff = getCutoffDate();
    const ps = Array.from(doc.querySelectorAll('p[data-type="social"][data-date]'));
    setStatus(`found ${ps.length} social nodes`);

    const posts = [];
    ps.forEach(el => {
      const date = parseDateFromDataDate(el.getAttribute('data-date'));
      if (!date || date < cutoff) return;
      const handles = new Set();
      el.querySelectorAll('a[href]').forEach(a => {
        const h = extractHandleFromHref(a.getAttribute('href'));
        if (h) handles.add(h.toLowerCase());
      });
      if (handles.size >= 1) posts.push({ date, handles });
    });
    posts.sort((a,b)=>a.date-b.date);
    rawPosts = posts;
    setStatus(`parsed ${posts.length} posts since 2025-09-22`);
  }

  function buildGraph(minMentions = 1) {
    // 1) Raw mention counts for filtering (no decay)
    const rawMentionCounts = new Map();

    // 2) Decayed mention totals for normalization
    const decayedMentions = new Map();

    // 3) Decayed co-mentions
    const linkKey = (a,b) => a < b ? `${a}|${b}` : `${b}|${a}`;
    const linksMap = new Map();

    for (const p of rawPosts) {
      const hs = [...p.handles];
      // weight by recency
      const w = Math.max(0, 1 - 0.01 * daysAgo(p.date));

      // update raw + decayed per-handle tallies
      for (const h of hs) {
        rawMentionCounts.set(h, (rawMentionCounts.get(h) || 0) + 1);
        decayedMentions.set(h, (decayedMentions.get(h) || 0) + w);
      }

      // decayed co-mentions
      if (hs.length >= 2) {
        for (let i = 0; i < hs.length; i++) {
          for (let j = i + 1; j < hs.length; j++) {
            const a = hs[i], b = hs[j];
            const key = linkKey(a, b);
            const prev = linksMap.get(key) || { source: a, target: b, co: 0 };
            prev.co += w; // accumulate decayed co-mentions
            linksMap.set(key, prev);
          }
        }
      }
    }

    // 4) Eligible nodes by raw count (UI-friendly)
    const eligible = new Set(
      [...rawMentionCounts.entries()]
        .filter(([, c]) => c >= minMentions)
        .map(([h]) => h)
    );

    // 5) Build normalized links using closeness = co / (decayedA + decayedB)
    const links = [];
    for (const { source, target, co } of linksMap.values()) {
      if (!eligible.has(source) || !eligible.has(target)) continue;
      const denom = (decayedMentions.get(source) || 0) + (decayedMentions.get(target) || 0);
      if (denom <= 0) continue;
      const value = co / denom; // normalized closeness in (0, 0.5]
      if (value > 0) links.push({ source, target, value });
    }

    // 6) Nodes carry raw mentions (for size/tooltip), but keep both if you want later
    const nodes = [...eligible].map(h => ({
      id: h,
      handle: h,
      mentions: rawMentionCounts.get(h) || 0,
      _decayed: decayedMentions.get(h) || 0 // not displayed; handy if needed
    }));

    return { nodes, links };
  }

  // ===== Layout + interactions (vanilla) =====
  // --- Touch (mobile) gestures: 1-finger pan, 2-finger pinch zoom ---

  let touchState = {
    mode: 'none',             // 'none' | 'pan' | 'pinch'
    lastX: 0, lastY: 0,       // for pan
    startZoom: 1,             // for pinch
    startDist: 1,             // for pinch
    anchorWorld: {x:0,y:0},   // world point under the pinch midpoint at gesture start
  };

  function touchDistance(t1, t2) {
    const dx = t2.clientX - t1.clientX;
    const dy = t2.clientY - t1.clientY;
    return Math.hypot(dx, dy);
  }

  function touchMidpoint(t1, t2) {
    return { x: (t1.clientX + t2.clientX)/2, y: (t1.clientY + t2.clientY)/2 };
  }

  graphEl.addEventListener('touchstart', (e) => {
    if (e.touches.length === 1) {
      // Start pan
      touchState.mode = 'pan';
      touchState.lastX = e.touches[0].clientX;
      touchState.lastY = e.touches[0].clientY;
    } else if (e.touches.length === 2) {
      // Start pinch
      const [t1, t2] = e.touches;
      touchState.mode = 'pinch';
      touchState.startDist = touchDistance(t1, t2);
      touchState.startZoom = zoom;

      const mid = touchMidpoint(t1, t2);
      // world point under fingers at start (like wheel-zoom focal point)
      const rect = canvas.getBoundingClientRect();
      const sx = mid.x - rect.left, sy = mid.y - rect.top;
      touchState.anchorWorld = { x: (sx - offsetX)/zoom, y: (sy - offsetY)/zoom };
    }
    e.preventDefault();
  }, { passive: false });

  graphEl.addEventListener('touchmove', (e) => {
    if (touchState.mode === 'pan' && e.touches.length === 1) {
      const nx = e.touches[0].clientX, ny = e.touches[0].clientY;
      offsetX += (nx - touchState.lastX);
      offsetY += (ny - touchState.lastY);
      touchState.lastX = nx; touchState.lastY = ny;
      render();
    } else if (touchState.mode === 'pinch' && e.touches.length === 2) {
      const [t1, t2] = e.touches;
      const dist = touchDistance(t1, t2);
      const rect = canvas.getBoundingClientRect();
      const mid = touchMidpoint(t1, t2);
      const sx = mid.x - rect.left, sy = mid.y - rect.top;

      // scale from start
      const newZoom = Math.max(0.25, Math.min(6, touchState.startZoom * (dist / touchState.startDist)));

      // keep the anchor world point under the same screen point
      const beforeWorld = touchState.anchorWorld; // fixed world point
      // after zoom, offset must be adjusted:
      offsetX = sx - beforeWorld.x * newZoom;
      offsetY = sy - beforeWorld.y * newZoom;

      zoom = newZoom;
      render();
    }
    e.preventDefault();
  }, { passive: false });

  graphEl.addEventListener('touchend', (e) => {
    if (e.touches.length === 0) {
      touchState.mode = 'none';
    } else if (e.touches.length === 1) {
      // If a pinch ended and one finger remains, switch to pan
      touchState.mode = 'pan';
      touchState.lastX = e.touches[0].clientX;
      touchState.lastY = e.touches[0].clientY;
    }
    e.preventDefault();
  }, { passive: false });

  // Zoom/pan
  let zoom = 1, offsetX = 0, offsetY = 0;
  function screenToWorld(x,y){ return { x:(x - offsetX)/zoom, y:(y - offsetY)/zoom }; }
  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const scale = Math.exp(-e.deltaY * 0.0015);
    const rect = canvas.getBoundingClientRect();
    const cx = e.clientX - rect.left, cy = e.clientY - rect.top;
    const before = screenToWorld(cx, cy);
    zoom = Math.max(0.25, Math.min(6, zoom * scale));
    const after = screenToWorld(cx, cy);
    offsetX += (after.x - before.x) * zoom;
    offsetY += (after.y - before.y) * zoom;
    render();
  }, { passive:false });
  let panning=false, lastX=0, lastY=0;
  canvas.addEventListener('mousedown', e=>{ panning=true; lastX=e.clientX; lastY=e.clientY; });
  window.addEventListener('mouseup', ()=>{ panning=false; });
  window.addEventListener('mousemove', e=>{
    if (!panning) return;
    offsetX += (e.clientX - lastX);
    offsetY += (e.clientY - lastY);
    lastX = e.clientX; lastY = e.clientY;
    render();
  });

  // Force sim state
  let nodes=[], links=[];
  let animId = null;

  // (A) adjacency map available to the simulation
  let neighbors = new Map();

  function layoutGraph() {
    // Initial jittered grid
    const W = canvas.parentElement.clientWidth, H = canvas.parentElement.clientHeight;
    nodes.forEach((n,i)=>{
      const cols = Math.ceil(Math.sqrt(nodes.length));
      const x = (i % cols) / (cols - 1 || 1);
      const y = Math.floor(i / cols) / (cols - 1 || 1);
      n.x = 40 + x*(W-80) + (Math.random()-0.5)*24;
      n.y = 40 + y*(H-80) + (Math.random()-0.5)*24;
      n.vx = 0; n.vy = 0;
    });

    // Link lengths from weights
    const vals = links.map(l=>l.value||0);
    let vmin=0, vmax=1; if (vals.length){ vmin=Math.min(...vals); vmax=Math.max(...vals); if (vmax===vmin) vmax=vmin+1; }
    links.forEach(l=>{
      const t = ((l.value||0) - vmin) / (vmax - vmin);
      const dMin = 26, dMax = Math.max(140, 0.55*Math.min(W,H));
      l.len = dMax - t*(dMax - dMin);
      l.a = nodes.find(n=>n.id===l.source);
      l.b = nodes.find(n=>n.id===l.target);
    });

    // (A) Build neighbors map once per layout
    neighbors = new Map();
    for (const n of nodes) neighbors.set(n.id, new Set());
    for (const l of links) {
      if (l.a && l.b) {
        neighbors.get(l.a.id).add(l.b.id);
        neighbors.get(l.b.id).add(l.a.id);
      }
    }

    // Simulation loop
    let steps = 0;
    function step() {
      steps++;
      const kSpring = 0.006;
      const centerK = 0.0005;
      const friction = 0.76;

      // (B) Tunables for repulsion/collision
      const kRepelConnected = 300;   // lighter for neighbors
      const kRepelNonEdge   = 2500;  // stronger for non-neighbors
      const kCollide        = 0.25;  // small stable separation
      const collidePad      = 6;     // extra pixels between "disks"

      // (B) Repulsion + collision
      for (let i=0;i<nodes.length;i++){
        for (let j=i+1;j<nodes.length;j++){
          const a=nodes[i], b=nodes[j];
          let dx=b.x-a.x, dy=b.y-a.y;
          let d2=dx*dx+dy*dy;
          if (d2===0){ dx=(Math.random()-0.5)*1e-3; dy=(Math.random()-0.5)*1e-3; d2=dx*dx+dy*dy; }
          const dist = Math.sqrt(d2);

          // stronger push if NOT directly connected
          const nbA = neighbors.get(a.id);
          const areNeighbors = nbA ? nbA.has(b.id) : false;
          const kRepel = areNeighbors ? kRepelConnected : kRepelNonEdge;

          const f = kRepel / d2;
          const fx = f * (dx / dist), fy = f * (dy / dist);
          a.vx -= fx; a.vy -= fy; b.vx += fx; b.vy += fy;

          // collision: prevent overlap of drawn circles
          const minDist = (nodeRadius(a) + nodeRadius(b) + collidePad);
          if (dist < minDist) {
            const overlap = (minDist - dist);
            const push = kCollide * overlap;
            const pfx = push * (dx / dist), pfy = push * (dy / dist);
            a.vx -= pfx; a.vy -= pfy; b.vx += pfx; b.vy += pfy;
          }
        }
      }

      // Springs
      for (const l of links){
        const a=l.a, b=l.b; if (!a||!b) continue;
        let dx=b.x-a.x, dy=b.y-a.y;
        let dist = Math.sqrt(dx*dx+dy*dy) || 1e-6;
        const diff = dist - l.len;
        const f = kSpring * diff;
        const fx = f * dx/dist, fy = f * dy/dist;
        a.vx += fx; a.vy += fy; b.vx -= fx; b.vy -= fy;
      }

      // Centering + integrate
      const cx = W/2, cy = H/2;
      let kinetic = 0;
      for (const n of nodes){
        n.vx += (cx - n.x)*centerK;
        n.vy += (cy - n.y)*centerK;
        n.vx *= friction; n.vy *= friction;
        n.x += n.vx; n.y += n.vy;
        kinetic += n.vx*n.vx + n.vy*n.vy;
      }

      render();

      if (steps < 2000 && kinetic > 0.01) {
        animId = requestAnimationFrame(step);
      } else {
        setStatus(`layout settled in ${steps} steps`);
        animId = null;
      }
    }
    if (animId) cancelAnimationFrame(animId);
    animId = requestAnimationFrame(step);
  }

  // ===== Render =====
  function nodeRadius(n){ return 4 + Math.min(14, (n.mentions||0) * 1.2); }
  const labels = new Map();

  function render() {
    // Clear whole backing store (retina-safe) and paint black
    clearBlack();

    // World->screen transform
    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(zoom, zoom);

    // Edges (thin, constant)
    if (showEdges) {
      ctx.globalAlpha = 0.9;
      ctx.strokeStyle = '#ffffff';
      for (const l of links){
        const a=l.a, b=l.b; if (!a||!b) continue;
        ctx.beginPath(); ctx.lineWidth = 0.4;
        ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
      }
    }

    // Nodes (hollow)
    for (const n of nodes){
      ctx.beginPath();
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 1.2 / Math.max(1, zoom*0.9);
      ctx.arc(n.x, n.y, nodeRadius(n), 0, Math.PI*2);
      ctx.stroke();
    }

    ctx.restore();

    // Labels in screen space
    for (const n of nodes){
      let el = labels.get(n.id);
      if (!el) {
        el = document.createElement('a');
        el.href = `https://twitter.com/${n.handle}`;
        el.target = '_blank'; el.rel = 'noopener';
        el.style.position = 'absolute';
        el.style.color = '#fff';
        el.style.textDecoration = 'none';
        el.style.fontSize = '12px';
        el.style.padding = '2px 3px';
        el.style.borderRadius = '6px';
        el.textContent = '@' + n.handle;
        canvas.parentElement.appendChild(el);
        labels.set(n.id, el);
      }
      const r = nodeRadius(n);
      const sx = offsetX + n.x*zoom;
      const sy = offsetY + n.y*zoom;
      const rect = el.getBoundingClientRect();
      el.style.left = (sx - rect.width/2) + 'px';
      el.style.top  = (sy - r*zoom - rect.height - 4) + 'px';
    }
  }
  function clearLabels(){ labels.forEach(el=>el.remove()); labels.clear(); }

  // Tooltip
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left - offsetX) / zoom;
    const y = (e.clientY - rect.top  - offsetY) / zoom;
    let hit = null;
    for (let i=nodes.length-1;i>=0;i--){
      const n = nodes[i], r=nodeRadius(n);
      const dx=x-n.x, dy=y-n.y;
      if (dx*dx+dy*dy <= r*r) { hit = n; break; }
    }
    if (hit) {
      tooltip.style.display='block';
      tooltip.textContent = `@${hit.handle} — mentions: ${hit.mentions}`;
      tooltip.style.left = e.clientX + 'px';
      tooltip.style.top  = e.clientY + 'px';
    } else {
      tooltip.style.display='none';
    }
  });

  // ===== Recompute =====
  function recomputeAndRender() {
    // --- NEW: compute max mentions across all users and set slider max dynamically
    const mentionTotals = new Map();
    for (const p of rawPosts) {
      for (const h of p.handles) {
        mentionTotals.set(h, (mentionTotals.get(h) || 0) + 1);
      }
    }
    const vals = [...mentionTotals.values()];
    const maxMentions = vals.length ? Math.max(...vals) : 1;

    // Update slider bounds / value / label safely
    minCountInput.max = String(maxMentions);
    if ((+minCountInput.value || 1) > maxMentions) {
      minCountInput.value = String(maxMentions);
    }
    const minMentions = parseInt(minCountInput.value, 10) || 1;
    minCountLabel.textContent = String(minMentions);

    // Build + draw graph as before
    graph = buildGraph(minMentions);
    nodes = graph.nodes;
    links = graph.links.map(l => ({...l}));
    links.forEach(l => { l.a = nodes.find(n=>n.id===l.source); l.b = nodes.find(n=>n.id===l.target); });
    clearLabels();
    fitCanvas();
    clearBlack();
    if (!nodes.length) { setStatus(`no eligible nodes (max mentions: ${maxMentions})`); render(); return; }
    setStatus(`nodes: ${nodes.length} | links: ${links.length} | max mentions: ${maxMentions}`);
    layoutGraph();
  }

  // ===== Init =====
  (async function init(){
    try {
      setStatus('boot…');
      fitCanvas(); clearBlack();
      minCountLabel.textContent = minCountInput.value;
      await loadSocial();
      recomputeAndRender();
    } catch (err) {
      console.error(err);
      errEl.textContent = String(err.message || err);
    }
  })();

  // UI change
  minCountInput.addEventListener('input', () => {
    minCountLabel.textContent = minCountInput.value;
    recomputeAndRender();
  });
})();
</script>
</body>
</html>

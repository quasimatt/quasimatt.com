<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="icon" href="https://pbs.twimg.com/profile_images/1614420813800767490/mf6sQbCT_400x400.jpg" type="image/png">
<title>quasimatt.com social graph (this page lowkey crashes out on mobile. use desktop.)</title>
<style>
  :root { --bg:#000; --fg:#fff; --muted:#aaa; }
  html,body { margin:0; height:100%; background:var(--bg); color:var(--fg);
    font-family:"Helvetica Neue", Helvetica, Arial, system-ui, -apple-system, sans-serif; }
  a { color:var(--fg); text-decoration:underline; }
  .wrap { display:grid; grid-template-rows:auto 1fr; height:100%; }
  header { padding:12px 16px; border-bottom:1px solid #222; display:flex; align-items:center; gap:14px; flex-wrap:wrap; }
  header h1 { font-size:16px; margin:0; letter-spacing:.2px; font-weight:600; }
  header .controls { display:flex; align-items:center; gap:12px; flex-wrap:wrap; color:var(--muted); }
  label { font-size:12px; } input[type="range"]{ width:180px; }
  .hint { font-size:12px; color:var(--muted); }
  #graph { position:relative; width:100%; height:calc(100vh - 60px); }
  canvas { display:block; width:100%; height:100%; background:#000; }
  .tooltip { position:fixed; pointer-events:none; background:#000; color:#fff; padding:6px 8px; border:1px solid #333; border-radius:8px; font-size:12px; white-space:nowrap; transform:translate(-50%,-140%); display:none; z-index: 999999;}
  .legend { position:absolute; left:12px; bottom:12px; font-size:12px; color:var(--muted); }
  .error { color:#f66; font-size:12px; margin-left:8px; }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>quasimatt.com social graph</h1>
    <div class="controls">
      <label>min mentions: <span id="minCountLabel">1</span>
        <input id="minCount" type="range" min="1" max="10" value="1" step="1" />
      </label>
      <label>since: <strong>2025-09-22</strong></label>
      <span class="hint">(zoom: scroll, pan: drag. click labels to open X.)</span>
      <span id="status" class="hint"></span>
      <span id="error" class="error"></span>
    </div>
  </header>
  <div id="graph">
    <canvas id="c"></canvas>
    <div id="tooltip" class="tooltip"></div>
  </div>
</div>

<script>
(function () {
  // ===== DOM =====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const tooltip = document.getElementById('tooltip');
  const statusEl = document.getElementById('status');
  const errEl = document.getElementById('error');
  const minCountInput = document.getElementById('minCount');
  const minCountLabel = document.getElementById('minCountLabel');

  function setStatus(s){ statusEl.textContent = s; }
  window.addEventListener('error', e => { errEl.textContent = String(e.error || e.message || e); });

  // ===== Canvas (retina-safe) =====
  function fitCanvas() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const { clientWidth:w, clientHeight:h } = canvas.parentElement;
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  function clearBlack() {
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
  }
  window.addEventListener('resize', () => { fitCanvas(); render(); });

  // ===== Config & helpers =====
  const SOCIAL_URL = '/social';
  const CUTOFF_ISO = '2025-09-22';
  const TW_HOSTS = new Set(['twitter.com','x.com','mobile.twitter.com']);

  function parseDateFromDataDate(val) {
    if (!val) return null;
    const s = String(val).trim();
    if (/^\d{6}$/.test(s)) { const mm=+s.slice(0,2), dd=+s.slice(2,4), yy=+s.slice(4,6); const d=new Date(2000+yy, mm-1, dd); return isNaN(d)?null:d; }
    if (/^\d{8}$/.test(s)) { const mm=+s.slice(0,2), dd=+s.slice(2,4), yyyy=+s.slice(4,8); const d=new Date(yyyy, mm-1, dd); return isNaN(d)?null:d; }
    return null;
  }
  function getCutoffDate(){ const [y,m,d]=CUTOFF_ISO.split('-').map(Number); return new Date(y,m-1,d); }
  function daysAgo(date){ return Math.max(0, Math.floor((Date.now()-date.getTime())/86400000)); }
  function extractHandleFromHref(href) {
    try {
      const u = new URL(href, location.origin);
      if (TW_HOSTS.has(u.hostname)) {
        const seg = u.pathname.split('/').filter(Boolean)[0] || '';
        return seg.replace(/^@/, '').trim();
      }
      return null;
    } catch { return null; }
  }

  // ===== Data =====
  let rawPosts = [];
  let graph = { nodes:[], links:[] };

  async function loadSocial() {
    setStatus('fetching /socialâ€¦');
    const res = await fetch(SOCIAL_URL, { credentials:'same-origin' });
    if (!res.ok) throw new Error('Failed to fetch /social');
    const html = await res.text();
    const doc = new DOMParser().parseFromString(html, 'text/html');

    const cutoff = getCutoffDate();
    const ps = Array.from(doc.querySelectorAll('p[data-type="social"][data-date]'));
    setStatus(`found ${ps.length} social nodes`);

    const posts = [];
    ps.forEach(el => {
      const date = parseDateFromDataDate(el.getAttribute('data-date'));
      if (!date || date < cutoff) return;
      const handles = new Set();
      el.querySelectorAll('a[href]').forEach(a => {
        const h = extractHandleFromHref(a.getAttribute('href'));
        if (h) handles.add(h.toLowerCase());
      });
      if (handles.size >= 1) posts.push({ date, handles });
    });
    posts.sort((a,b)=>a.date-b.date);
    rawPosts = posts;
    setStatus(`parsed ${posts.length} posts since 2025-09-22`);
  }

  function buildGraph(minMentions = 1) {
  // 1) Raw mention counts for filtering (no decay)
  const rawMentionCounts = new Map();

  // 2) Decayed mention totals for normalization
  const decayedMentions = new Map();

  // 3) Decayed co-mentions
  const linkKey = (a,b) => a < b ? `${a}|${b}` : `${b}|${a}`;
  const linksMap = new Map();

  for (const p of rawPosts) {
    const hs = [...p.handles];
    // weight by recency
    const w = Math.max(0, 1 - 0.01 * daysAgo(p.date));

    // update raw + decayed per-handle tallies
    for (const h of hs) {
      rawMentionCounts.set(h, (rawMentionCounts.get(h) || 0) + 1);
      decayedMentions.set(h, (decayedMentions.get(h) || 0) + w);
    }

    // decayed co-mentions
    if (hs.length >= 2) {
      for (let i = 0; i < hs.length; i++) {
        for (let j = i + 1; j < hs.length; j++) {
          const a = hs[i], b = hs[j];
          const key = linkKey(a, b);
          const prev = linksMap.get(key) || { source: a, target: b, co: 0 };
          prev.co += w; // accumulate decayed co-mentions
          linksMap.set(key, prev);
        }
      }
    }
  }

  // 4) Eligible nodes by raw count (UI-friendly)
  const eligible = new Set(
    [...rawMentionCounts.entries()]
      .filter(([, c]) => c >= minMentions)
      .map(([h]) => h)
  );

  // 5) Build normalized links using closeness = co / (decayedA + decayedB)
  const links = [];
  for (const { source, target, co } of linksMap.values()) {
    if (!eligible.has(source) || !eligible.has(target)) continue;
    const denom = (decayedMentions.get(source) || 0) + (decayedMentions.get(target) || 0);
    if (denom <= 0) continue;
    const value = co / denom; // normalized closeness in (0, 0.5]
    if (value > 0) links.push({ source, target, value });
  }

  // 6) Nodes carry raw mentions (for size/tooltip), but keep both if you want later
  const nodes = [...eligible].map(h => ({
    id: h,
    handle: h,
    mentions: rawMentionCounts.get(h) || 0,
    _decayed: decayedMentions.get(h) || 0 // not displayed; handy if needed
  }));

  return { nodes, links };
}

  // ===== Layout + interactions (vanilla) =====
  // Zoom/pan
  let zoom = 1, offsetX = 0, offsetY = 0;
  function screenToWorld(x,y){ return { x:(x - offsetX)/zoom, y:(y - offsetY)/zoom }; }
  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const scale = Math.exp(-e.deltaY * 0.0015);
    const rect = canvas.getBoundingClientRect();
    const cx = e.clientX - rect.left, cy = e.clientY - rect.top;
    const before = screenToWorld(cx, cy);
    zoom = Math.max(0.25, Math.min(6, zoom * scale));
    const after = screenToWorld(cx, cy);
    offsetX += (after.x - before.x) * zoom;
    offsetY += (after.y - before.y) * zoom;
    render();
  }, { passive:false });
  let panning=false, lastX=0, lastY=0;
  canvas.addEventListener('mousedown', e=>{ panning=true; lastX=e.clientX; lastY=e.clientY; });
  window.addEventListener('mouseup', ()=>{ panning=false; });
  window.addEventListener('mousemove', e=>{
    if (!panning) return;
    offsetX += (e.clientX - lastX);
    offsetY += (e.clientY - lastY);
    lastX = e.clientX; lastY = e.clientY;
    render();
  });

  // Force sim state
  let nodes=[], links=[];
  let animId = null;

  function layoutGraph() {
    // Initial jittered grid
    const W = canvas.parentElement.clientWidth, H = canvas.parentElement.clientHeight;
    nodes.forEach((n,i)=>{
      const cols = Math.ceil(Math.sqrt(nodes.length));
      const x = (i % cols) / (cols - 1 || 1);
      const y = Math.floor(i / cols) / (cols - 1 || 1);
      n.x = 40 + x*(W-80) + (Math.random()-0.5)*24;
      n.y = 40 + y*(H-80) + (Math.random()-0.5)*24;
      n.vx = 0; n.vy = 0;
    });

    // Link lengths from weights
    const vals = links.map(l=>l.value||0);
    let vmin=0, vmax=1; if (vals.length){ vmin=Math.min(...vals); vmax=Math.max(...vals); if (vmax===vmin) vmax=vmin+1; }
    links.forEach(l=>{
      const t = ((l.value||0) - vmin) / (vmax - vmin);
      const dMin = 26, dMax = Math.max(140, 0.55*Math.min(W,H));
      l.len = dMax - t*(dMax - dMin);
      l.a = nodes.find(n=>n.id===l.source);
      l.b = nodes.find(n=>n.id===l.target);
    });

    // Simulation loop
    let steps = 0;
    function step() {
      steps++;
      const kSpring = 0.01;
      const kRepel = 2500;
      const centerK = 0.0005;
      const friction = 0.85;

      // Repulsion
      for (let i=0;i<nodes.length;i++){
        for (let j=i+1;j<nodes.length;j++){
          const a=nodes[i], b=nodes[j];
          let dx=b.x-a.x, dy=b.y-a.y, d2=dx*dx+dy*dy;
          if (d2===0){ dx=(Math.random()-0.5)*1e-3; dy=(Math.random()-0.5)*1e-3; d2=dx*dx+dy*dy; }
          const f = kRepel / d2;
          const dist = Math.sqrt(d2);
          const fx = f * dx/dist, fy = f * dy/dist;
          a.vx -= fx; a.vy -= fy; b.vx += fx; b.vy += fy;
        }
      }

      // Springs
      for (const l of links){
        const a=l.a, b=l.b; if (!a||!b) continue;
        let dx=b.x-a.x, dy=b.y-a.y;
        let dist = Math.sqrt(dx*dx+dy*dy) || 1e-6;
        const diff = dist - l.len;
        const f = kSpring * diff;
        const fx = f * dx/dist, fy = f * dy/dist;
        a.vx += fx; a.vy += fy; b.vx -= fx; b.vy -= fy;
      }

      // Centering + integrate
      const cx = W/2, cy = H/2;
      let kinetic = 0;
      for (const n of nodes){
        n.vx += (cx - n.x)*centerK;
        n.vy += (cy - n.y)*centerK;
        n.vx *= friction; n.vy *= friction;
        n.x += n.vx; n.y += n.vy;
        kinetic += n.vx*n.vx + n.vy*n.vy;
      }

      render();

      if (steps < 800 && kinetic > 0.01) {
        animId = requestAnimationFrame(step);
      } else {
        setStatus(`layout settled in ${steps} steps`);
        animId = null;
      }
    }
    if (animId) cancelAnimationFrame(animId);
    animId = requestAnimationFrame(step);
  }

  // ===== Render =====
  function nodeRadius(n){ return 4 + Math.min(14, (n.mentions||0) * 1.2); }
  const labels = new Map();

  function render() {
    // Clear whole backing store (retina-safe) and paint black
    clearBlack();

    // World->screen transform
    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(zoom, zoom);

    // Edges (thin, constant)
    ctx.globalAlpha = 0.9;
    ctx.strokeStyle = '#ffffff';
    for (const l of links){
      const a=l.a, b=l.b; if (!a||!b) continue;
      ctx.beginPath(); ctx.lineWidth = 0.4;
      ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
    }

    // Nodes (hollow)
    for (const n of nodes){
      ctx.beginPath();
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 1.2 / Math.max(1, zoom*0.9);
      ctx.arc(n.x, n.y, nodeRadius(n), 0, Math.PI*2);
      ctx.stroke();
    }

    ctx.restore();

    // Labels in screen space
    for (const n of nodes){
      let el = labels.get(n.id);
      if (!el) {
        el = document.createElement('a');
        el.href = `https://twitter.com/${n.handle}`;
        el.target = '_blank'; el.rel = 'noopener';
        el.style.position = 'absolute';
        el.style.color = '#fff';
        el.style.textDecoration = 'none';
        el.style.fontSize = '12px';
        el.style.padding = '2px 3px';
        el.style.borderRadius = '6px';
        el.textContent = '@' + n.handle;
        canvas.parentElement.appendChild(el);
        labels.set(n.id, el);
      }
      const r = nodeRadius(n);
      const sx = offsetX + n.x*zoom;
      const sy = offsetY + n.y*zoom;
      const rect = el.getBoundingClientRect();
      el.style.left = (sx - rect.width/2) + 'px';
      el.style.top  = (sy - r*zoom - rect.height - 4) + 'px';
    }
  }
  function clearLabels(){ labels.forEach(el=>el.remove()); labels.clear(); }

  // Tooltip
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left - offsetX) / zoom;
    const y = (e.clientY - rect.top  - offsetY) / zoom;
    let hit = null;
    for (let i=nodes.length-1;i>=0;i--){
      const n = nodes[i], r=nodeRadius(n);
      const dx=x-n.x, dy=y-n.y;
      if (dx*dx+dy*dy <= r*r) { hit = n; break; }
    }
    if (hit) {
      tooltip.style.display='block';
      tooltip.textContent = `@${hit.handle} â€” mentions: ${hit.mentions}`;
      tooltip.style.left = e.clientX + 'px';
      tooltip.style.top  = e.clientY + 'px';
    } else {
      tooltip.style.display='none';
    }
  });

  // ===== Recompute =====
  function recomputeAndRender() {
    const minMentions = parseInt(minCountInput.value, 10) || 1;
    graph = buildGraph(minMentions);
    nodes = graph.nodes;
    links = graph.links.map(l => ({...l}));
    links.forEach(l => { l.a = nodes.find(n=>n.id===l.source); l.b = nodes.find(n=>n.id===l.target); });
    clearLabels();
    fitCanvas();
    clearBlack();
    if (!nodes.length) { setStatus('no eligible nodes with current filter'); render(); return; }
    setStatus(`nodes: ${nodes.length} | links: ${links.length}`);
    layoutGraph();
  }

  // ===== Init =====
  (async function init(){
    try {
      setStatus('bootâ€¦');
      fitCanvas(); clearBlack();
      minCountLabel.textContent = minCountInput.value;
      await loadSocial();
      recomputeAndRender();
    } catch (err) {
      console.error(err);
      errEl.textContent = String(err.message || err);
    }
  })();

  // UI change
  minCountInput.addEventListener('input', () => {
    minCountLabel.textContent = minCountInput.value;
    recomputeAndRender();
  });
})();
</script>
</body>
</html>


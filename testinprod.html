<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>together</title>
  <style>
    html, body { margin:0; height:100%; background:#000; }
    body { font-family:"Helvetica Neue", Helvetica, Arial, system-ui, -apple-system, sans-serif; }
    canvas { display:block; width:100%; height:100%; }
  </style>
</head>
<body>
  <canvas id="stage"></canvas>
  <script>
  (function(){
    // ============== Core app / slide lifecycle ==============
    const stage = document.getElementById('stage');
    const ctx = stage.getContext('2d');

    const app = {
      stage, ctx,
      dpr: Math.max(1, Math.min(2, window.devicePixelRatio || 1)),
      w: 0, h: 0, dt: 0, now: 0,
      slideIndex: 0, slides: [], currentSlide: null,
      setSize(){
        this.w = Math.floor(innerWidth * this.dpr);
        this.h = Math.floor(innerHeight * this.dpr);
        stage.width = this.w; stage.height = this.h;
        stage.style.width = innerWidth + 'px';
        stage.style.height = innerHeight + 'px';
        this.currentSlide?.onResize?.(this);
      },
      goto(i){
        this.currentSlide?.destroy?.(this);
        this.slideIndex = (i % this.slides.length + this.slides.length) % this.slides.length;
        this.currentSlide = this.slides[this.slideIndex];
        this.currentSlide?.init?.(this);
      },
      next(){ this.goto(this.slideIndex + 1); }
    };

    // Route input only to active slide
    const pointer = { x:0, y:0, down:false };
    function toPx(e){ const r = stage.getBoundingClientRect(); return { x:(e.clientX-r.left)*app.dpr, y:(e.clientY-r.top)*app.dpr }; }

    stage.addEventListener('pointerdown', e=>{ const p=toPx(e); pointer.x=p.x; pointer.y=p.y; pointer.down=true; app.currentSlide?.onPointerDown?.(e, pointer, app); try{stage.setPointerCapture(e.pointerId);}catch(_){} });
    stage.addEventListener('pointermove', e=>{ const p=toPx(e); pointer.x=p.x; pointer.y=p.y; app.currentSlide?.onPointerMove?.(e, pointer, app); });
    ['pointerup','pointercancel','pointerleave','pointerout'].forEach(t=> stage.addEventListener(t, e=>{ pointer.down=false; app.currentSlide?.onPointerUp?.(e, pointer, app); }));

    // Click anywhere → next slide
    addEventListener('click', ()=> app.next());
    addEventListener('resize', ()=> app.setSize(), { passive:true });

    // ============== Slide 1 (self-contained) ==============
    // Black background; large “together” + small “by quasimatt”.
    // Mouse near/over text erases it (turns those glyph pixels black permanently).
    // When ALL text pixels are erased → advance.
    const Slide1 = {
      name: 'slide-1-erase',
      textCanvas: document.createElement('canvas'),
      tctx: null,
      probe: document.createElement('canvas'),
      pctx: null,
      last: null,
      MAIN: 'together',
      SUB:  'by quasimatt',

      init(app){
        this.tctx = this.textCanvas.getContext('2d');
        this.pctx = this.probe.getContext('2d', { willReadFrequently: true });
        this.probe.width = 160; this.probe.height = 90;
        this.onResize(app);
        this.drawText(app);
      },
      onResize(app){
        this.textCanvas.width = app.w;
        this.textCanvas.height = app.h;
        this.drawText(app);
      },
      brushRadius(app){ return Math.max(60, Math.min(260, Math.floor(app.w * 0.06))); },
      wrapLines(c, text, font, maxW){
        c.font = font; const words = text.split(/\s+/); const lines=[]; let ln='';
        for (const w of words){ const test = ln ? (ln+' '+w) : w;
          if (c.measureText(test).width <= maxW || !ln) ln=test; else { lines.push(ln); ln=w; }
        }
        if (ln) lines.push(ln); return lines;
      },
      drawText(app){
        const c=this.tctx, W=this.textCanvas.width, H=this.textCanvas.height;
        c.setTransform(1,0,0,1,0,0); c.clearRect(0,0,W,H);
        const main = Math.max(120, Math.min(200, Math.floor(W*0.16))); // ≥ 120
        const sub  = Math.max(18,  Math.min(42,  Math.floor(W*0.02)));
        c.fillStyle = '#fff'; c.textAlign='center'; c.textBaseline='middle';
        const mainFont = `800 ${main}px "Helvetica Neue", Helvetica, Arial, system-ui, -apple-system, sans-serif`;
        const subFont  = `400 ${sub}px "Helvetica Neue", Helvetica, Arial, system-ui, -apple-system, sans-serif`;
        const lines = this.wrapLines(c, this.MAIN, mainFont, Math.floor(W*0.9));
        const gap = Math.floor(main*0.18);
        const blockH = lines.length*main + (lines.length-1)*gap + (this.SUB? sub*1.6:0);
        let y = (H - blockH)/2 + main/2;
        c.font = mainFont; for (const L of lines){ c.fillText(L, W/2, y); y += main + gap; }
        if (this.SUB){ c.font = subFont; c.fillText(this.SUB, W/2, y + sub*0.8); }
      },
      stamp(app, x, y){
        const r = this.brushRadius(app);
        const g = this.tctx.createRadialGradient(x,y,0,x,y,r);
        g.addColorStop(0.0,'rgba(0,0,0,1)');
        g.addColorStop(0.6,'rgba(0,0,0,0.6)');
        g.addColorStop(1.0,'rgba(0,0,0,0)');
        this.tctx.globalCompositeOperation='destination-out';
        this.tctx.fillStyle=g; this.tctx.beginPath(); this.tctx.arc(x,y,r,0,Math.PI*2); this.tctx.fill();
        this.tctx.globalCompositeOperation='source-over';
      },
      eraseLine(app, a, b){
        const r = this.brushRadius(app), dx=b.x-a.x, dy=b.y-a.y, d=Math.hypot(dx,dy);
        if (!d){ this.stamp(app, b.x,b.y); return; }
        const step = Math.max(1, r*0.4), n = Math.ceil(d/step);
        for (let i=0;i<=n;i++){ const t=i/n; this.stamp(app, a.x+dx*t, a.y+dy*t); }
      },
      allErased(){
        const p=this.pctx; p.clearRect(0,0,this.probe.width,this.probe.height);
        p.drawImage(this.textCanvas,0,0,this.probe.width,this.probe.height);
        const data=p.getImageData(0,0,this.probe.width,this.probe.height).data;
        for (let i=3;i<data.length;i+=4){ if (data[i]!==0) return false; }
        return true;
      },
      update(){ /* no-op */ },
      render(ctx, app){
        ctx.setTransform(1,0,0,1,0,0);
        ctx.fillStyle='#000'; ctx.fillRect(0,0,app.w,app.h);
        ctx.drawImage(this.textCanvas, 0, 0);
      },
      shouldAdvance(){ return this.allErased(); },
      onPointerDown(e, ptr, app){ this.last = {x:ptr.x,y:ptr.y}; this.stamp(app, ptr.x, ptr.y); },
      onPointerMove(e, ptr, app){
        // Hover/drag erasing so fast moves still fill in
        if (this.last) this.eraseLine(app, this.last, {x:ptr.x,y:ptr.y}); else this.stamp(app, ptr.x, ptr.y);
        this.last = {x:ptr.x, y:ptr.y};
      },
      onPointerUp(){ /* keep last to keep interpolation continuous */ },
      destroy(){ this.last=null; }
    };

    // ============== Slide 2 (self-contained) ==============
    // White background; black sentences scroll right→left.
    // When the LAST sentence's center reaches the screen center: freeze, turn bg black, last sentence white, hold 1s → next slide.
    const Slide2 = {
      name: 'slide-2-marquee',
      speed: 120, // px/sec @ dpr=1
      items: [],
      fontSize: 24,
      text:
        "i imagine a closeness with others that cannot exist. i compare my relationship with myself with my relationship to others. i have access to my every thought and feeling. i will never have this access for someone else. friends feel like acquaintences. acquaintences feel like strangers. everyone feels far away.",
      nextIndex: 0,
      sentencesCached: [],
      stopped: false,
      holdTimer: 0,
      lastItem: null,

      init(app){
        this.items = []; this.stopped=false; this.holdTimer=0; this.lastItem=null; this.nextIndex=0;
        this.onResize(app);
        this.sentencesCached = this.text.split(/(?<=[.!?])\s+/).map(s=>s.trim()).filter(Boolean);
        this.spawnNext(app, true);
      },
      onResize(app){ this.fontSize = Math.max(18, Math.min(48, Math.floor(app.w * 0.022))); },
      measure(text, fs){
        ctx.font = `600 ${fs}px "Helvetica Neue", Helvetica, Arial, system-ui, -apple-system, sans-serif`;
        return Math.ceil(ctx.measureText(text).width);
      },
      pickY(app){
        const margin = Math.max(40, Math.floor(app.h*0.1));
        const minGap = Math.max(30, Math.floor(this.fontSize*1.15));
        for (let tries=0; tries<20; tries++){
          const y = Math.floor(Math.random()*(app.h - 2*margin)) + margin;
          let clash=false; for (const it of this.items){ if (Math.abs(it.y - y) < minGap){ clash=true; break; } }
          if (!clash) return y;
        }
        return Math.floor(app.h/2);
      },
      spawnNext(app, initial){
        const sents = this.sentencesCached; if (!sents.length) return;
        if (this.nextIndex >= sents.length) return; // stop spawning beyond last
        const text = sents[this.nextIndex++];
        const isLast = (this.nextIndex === sents.length);
        const fs = this.fontSize;
        const w = this.measure(text, fs);
        const y = this.pickY(app);
        const x = app.w + (initial ? 0 : Math.floor(fs*0.6));
        const item = { text, x, y, w, fs, isLast };
        if (isLast) this.lastItem = item;
        this.items.push(item);
      },
      update(dt, app){
        if (this.stopped){
          this.holdTimer += dt;
          return;
        }
        const dx = this.speed * app.dpr * dt;
        for (const it of this.items) it.x -= dx;

        // Spawn next when the end of the last spawned appears onscreen
        const tail = this.items[this.items.length-1];
        if (tail && (tail.x + tail.w) <= app.w) this.spawnNext(app, false);

        // Clean out fully offscreen items
        while (this.items.length && this.items[0].x + this.items[0].w < 0) this.items.shift();

        // Stop when last sentence center reaches screen center
        if (this.lastItem){
          const center = this.lastItem.x + this.lastItem.w/2;
          const target = app.w/2;
          if (center <= target){
            // snap to perfect center, freeze
            this.lastItem.x = Math.floor(target - this.lastItem.w/2);
            this.stopped = true;
            // keep only the last item visible
            this.items = [ this.lastItem ];
          }
        }
      },
      render(ctx, app){
        if (!this.stopped){
          // scrolling state: white bg, black text
          ctx.setTransform(1,0,0,1,0,0);
          ctx.fillStyle = '#fff'; ctx.fillRect(0,0,app.w,app.h);
          ctx.textAlign='left'; ctx.textBaseline='middle'; ctx.fillStyle='#000';
          for (const it of this.items){
            ctx.font = `600 ${it.fs}px "Helvetica Neue", Helvetica, Arial, system-ui, -apple-system, sans-serif`;
            ctx.fillText(it.text, it.x, it.y);
          }
        } else {
          // frozen state: black bg, last sentence in white, centered
          ctx.setTransform(1,0,0,1,0,0);
          ctx.fillStyle = '#000'; ctx.fillRect(0,0,app.w,app.h);
          if (this.lastItem){
            ctx.textAlign='left'; ctx.textBaseline='middle'; ctx.fillStyle='#fff';
            ctx.font = `600 ${this.lastItem.fs}px "Helvetica Neue", Helvetica, Arial, system-ui, -apple-system, sans-serif`;
            ctx.fillText(this.lastItem.text, this.lastItem.x, this.lastItem.y);
          }
        }
      },
      shouldAdvance(){ return this.stopped && this.holdTimer >= 1.0; },
      destroy(){ this.items.length = 0; this.lastItem = null; }
    };

// ============== Slide 3: Social graph + timed typewriter text ==============
const Slide3 = {
  name: 'social-graph',
  // graph state
  nodes: [], links: [],
  loaded: false, error: null,
  pointerInside: false, px: 0, py: 0,
  fontPx: 12,
  cutoffISO: '2025-09-22',

  // typewriter state
  text: "we can understand other people through their context. where do they go? what do they do? who do they know?",
  textTimer: 0,
  textDelay: 3.0,      // seconds before text starts
  textSpeed: 90,       // chars per second
  textCharsShown: 0,   // running total of visible chars

  // dot state
  dotVisible: false,
  dotRadius: 14,
  dotHoverAdvance: false,
  dotDelayAfterText: 3.0, // seconds after text starts

  // --- lifecycle ---
  init(app){
    this.loaded = false; this.error = null;
    this.nodes = []; this.links = [];
    this.fontPx = Math.max(14, Math.min(22, Math.floor(app.w * 0.016))); // slightly larger labels
    this.textTimer = 0;
    this.textCharsShown = 0;
    this.dotVisible = false;
    this.dotHoverAdvance = false;

    this.loadSocial().then(() => {
      this.layoutInit(app);
      this.loaded = true;
    }).catch(err => { this.error = String(err && err.message || err); });
  },
  onResize(app){
    this.fontPx = Math.max(14, Math.min(22, Math.floor(app.w * 0.016)));
  },
  destroy(){ this.nodes = []; this.links = []; },

  // --- input ---
  onPointerMove(e, ptr, app){
    this.pointerInside = true;
    this.px = ptr.x;
    this.py = ptr.y;

    // If the dot is visible, detect hover → request advance
    if (this.dotVisible){
      const cx = app.w / 2;
      const cy = app.h - 40;
      const dx = this.px - cx;
      const dy = this.py - cy;
      if (dx*dx + dy*dy <= this.dotRadius * this.dotRadius){
        this.dotHoverAdvance = true;
      }
    }
  },
  onPointerUp(){ this.pointerInside = false; },

  // --- helpers: data parsing ---
  cutoff(){ const [Y,M,D] = this.cutoffISO.split('-').map(Number); return new Date(Y, M-1, D); },
  parseDataDate(code){
    if (!code) return null; const s = String(code).trim();
    if (/^\d{6}$/.test(s)){ const mm=+s.slice(0,2), dd=+s.slice(2,4), yy=+s.slice(4,6); return new Date(2000+yy, mm-1, dd); }
    if (/^\d{8}$/.test(s)){ const mm=+s.slice(0,2), dd=+s.slice(2,4), yyyy=+s.slice(4,8); return new Date(yyyy, mm-1, dd); }
    return null;
  },
  extractAccount(href){
    try {
      const u = new URL(href, location.origin);
      const host = u.hostname.toLowerCase();

      // X / Twitter
      if (host === 'x.com' || host === 'twitter.com' || host === 'mobile.twitter.com'){
        const seg = (u.pathname.split('/').filter(Boolean)[0]||'').replace(/^@/,'');
        if (!seg) return null;
        const handle = seg.toLowerCase();
        return { id:`x:${handle}`, platform:'x', handle, url:`https://twitter.com/${handle}` };
      }
      // Instagram
      if (host === 'instagram.com' || host === 'www.instagram.com' || host === 'm.instagram.com'){
        const p = u.pathname.split('/').filter(Boolean); const first=(p[0]||'').toLowerCase();
        const bad = new Set(['p','reel','reels','stories','explore','tv','accounts']);
        if (!first || bad.has(first) || !/^[a-z0-9._]{1,30}$/i.test(first)) return null;
        const handle = first.toLowerCase();
        return { id:`ig:${handle}`, platform:'ig', handle, url:`https://instagram.com/${handle}` };
      }
      return null;
    } catch { return null; }
  },

  // --- data load (same-origin /social) ---
  async loadSocial(){
    const res = await fetch('/social', { credentials:'same-origin' });
    if (!res.ok) throw new Error('Failed to fetch /social');
    const html = await res.text();
    const doc = new DOMParser().parseFromString(html, 'text/html');

    const cutoff = this.cutoff();
    const ps = Array.from(doc.querySelectorAll("p[data-type='social'][data-date]"));
    const posts = [];
    const meta = new Map();

    for (const el of ps){
      const dt = this.parseDataDate(el.getAttribute('data-date'));
      if (!dt || dt < cutoff) continue;

      const ids = new Set();
      el.querySelectorAll('a[href]').forEach(a => {
        const acc = this.extractAccount(a.getAttribute('href'));
        if (acc){ ids.add(acc.id); if (!meta.has(acc.id)) meta.set(acc.id, acc); }
      });
      if (ids.size) posts.push({ date: dt, ids: [...ids] });
    }
    posts.sort((a,b)=> a.date - b.date);

    // minMentions = 1
    const counts = new Map();
    for (const p of posts){ for (const id of p.ids) counts.set(id, (counts.get(id)||0)+1); }
    const eligible = [...counts.keys()];
    const elig = new Set(eligible);

    // nodes
    this.nodes = eligible.map(id => ({
      id,
      handle: (meta.get(id)?.handle) || id.split(':').pop(),
      platform: (meta.get(id)?.platform) || 'x',
      url: (meta.get(id)?.url) || '',
      mentions: counts.get(id) || 1,
      x: 0, y: 0, vx: 0, vy: 0,
      r: 6 + Math.min(12, (counts.get(id)||1)*1.2)
    }));

    // links (co-mentions, unweighted layout length for simplicity)
    const key = (a,b)=> a<b ? `${a}|${b}` : `${b}|${a}`;
    const map = new Map();
    for (const p of posts){
      const ids = p.ids.filter(id=>elig.has(id));
      for (let i=0;i<ids.length;i++){
        for (let j=i+1;j<ids.length;j++){
          const k = key(ids[i], ids[j]);
          map.set(k, (map.get(k)||0)+1);
        }
      }
    }
    this.links = [];
    for (const [k,v] of map){
      const [a,b] = k.split('|');
      const A = this.nodes.find(n=>n.id===a), B = this.nodes.find(n=>n.id===b);
      if (A && B) this.links.push({ a:A, b:B, value:v, len:120 });
    }
  },

  // --- layout bootstrap ---
  layoutInit(app){
    const W = app.w, H = app.h;
    const N = this.nodes.length || 1;
    const cols = Math.ceil(Math.sqrt(N));
    this.nodes.forEach((n,i)=>{
      const x = (i % cols) / (cols-1 || 1);
      const y = Math.floor(i/cols) / (cols-1 || 1);
      // margins but let the graph basically fill the screen
      n.x = 60 + x*(W-120) + (Math.random()-0.5)*20;
      n.y = 60 + y*(H-120) + (Math.random()-0.5)*20;
      n.vx = 0; n.vy = 0;
    });
  },

  // --- simulation/update ---
  update(dt, app){
    if (!this.loaded || !this.nodes.length) return;

    // advance typewriter state
    this.textTimer += dt;
    if (this.textTimer >= this.textDelay && this.textCharsShown < this.text.length){
      this.textCharsShown = Math.min(this.text.length, this.textCharsShown + this.textSpeed * dt);
    }

    // show dot a few seconds after text starts typing
    if (!this.dotVisible && this.textTimer >= this.textDelay + this.dotDelayAfterText){
      this.dotVisible = true;
    }

    const W = app.w, H = app.h, cx = W/2, cy = H/2;

    const springK   = 0.006;
    const centerK   = 0.0008;
    const friction  = 0.78;
    const repelK    = 2200;  // node-node
    const collideK  = 0.25;
    const pad       = 6;

    const pointerK  = 18000;
    const pointerR  = Math.max(100, Math.min(240, Math.floor(Math.min(W,H)*0.18)));
    const pR2       = pointerR * pointerR;

    // pairwise repulsion + soft collision
    for (let i=0;i<this.nodes.length;i++){
      const a = this.nodes[i];
      for (let j=i+1;j<this.nodes.length;j++){
        const b = this.nodes[j];
        let dx = b.x - a.x, dy = b.y - a.y;
        let d2 = dx*dx + dy*dy;
        if (d2 === 0){ dx=(Math.random()-0.5)*1e-3; dy=(Math.random()-0.5)*1e-3; d2 = dx*dx + dy*dy; }
        const d = Math.sqrt(d2);
        const f = repelK / d2;
        const fx = f * (dx/d), fy = f * (dy/d);
        a.vx -= fx; a.vy -= fy; b.vx += fx; b.vy += fy;

        const minD = (a.r + b.r) + pad;
        if (d < minD){
          const push = collideK * (minD - d);
          const pfx = push * (dx/d), pfy = push * (dy/d);
          a.vx -= pfx; a.vy -= pfy; b.vx += pfx; b.vy += pfy;
        }
      }
    }

    // springs along links
    for (const l of this.links){
      const a = l.a, b = l.b;
      let dx = b.x - a.x, dy = b.y - a.y;
      const d = Math.hypot(dx,dy) || 1e-6;
      const f = springK * (d - l.len);
      const fx = f * (dx/d), fy = f * (dy/d);
      a.vx += fx; a.vy += fy; b.vx -= fx; b.vy -= fy;
    }

    // pointer repulsion: "run away from mouse"
    if (this.pointerInside){
      const px = this.px, py = this.py;
      for (const n of this.nodes){
        const dx = n.x - px, dy = n.y - py;
        const d2 = dx*dx + dy*dy;
        if (d2 < pR2){
          const d = Math.sqrt(d2) || 1e-6;
          const f = pointerK / (d2 + 1);
          n.vx += f * (dx/d);
          n.vy += f * (dy/d);
        }
      }
    }

    // center + integrate
    for (const n of this.nodes){
      n.vx += (cx - n.x) * centerK;
      n.vy *= friction; n.vx *= friction;
      n.y += n.vy; n.x += n.vx;
    }
  },

  // --- draw (graph fullscreen + overlay text + dot) ---
  render(ctx, app){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,app.w,app.h);

    if (!this.loaded) return;

    // Draw graph labels across the whole screen
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#fff';
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 3;
    for (const n of this.nodes){
      ctx.font = `600 ${this.fontPx}px "Helvetica Neue", Helvetica, Arial, system-ui, -apple-system, sans-serif`;
      const label = `@${n.handle}`;
      ctx.strokeText(label, n.x, n.y);
      ctx.fillText(label,  n.x, n.y);
    }

    // After delay, typewriter text appears at the very top,
    // with tight black boxes behind each line (overlay).
    if (this.textTimer >= this.textDelay){
      const full = this.text;
      const shown = full.slice(0, Math.floor(this.textCharsShown));

      const fs = Math.max(22, Math.min(34, Math.floor(app.w * 0.024))); // bigger & bold
      const lh = Math.floor(fs * 1.4);
      const sideMargin = Math.floor(app.w * 0.06);
      const maxW = app.w - sideMargin*2;
      const topMargin = 16;

      function wrap(c, text, font, width){
        c.font = font;
        const words = text.split(/\s+/);
        const lines = [];
        let line = '';
        for (const w of words){
          const test = line ? line + ' ' + w : w;
          if (c.measureText(test).width <= width || !line) line = test;
          else { lines.push(line); line = w; }
        }
        if (line) lines.push(line);
        return lines;
      }

      const font = `700 ${fs}px "Helvetica Neue", Helvetica, Arial, system-ui, -apple-system, sans-serif`;
      const lines = wrap(ctx, shown, font, maxW);

      ctx.textAlign = 'left';
      ctx.textBaseline = 'alphabetic';
      ctx.font = font;

      const padX = 10;
      const padY = 6;
      let y = topMargin + lh;       // fixed vertical starting point
      const xStart = sideMargin;

      for (const L of lines){
        const w = ctx.measureText(L).width;
        // black box behind line
        ctx.fillStyle = '#000';
        ctx.fillRect(
          xStart - padX,
          y - lh - padY,
          w + padX*2,
          lh + padY*2
        );
        // white bold text
        ctx.fillStyle = '#fff';
        ctx.fillText(L, xStart, y);
        y += lh;
        if (y > app.h * 0.5) break; // don't go too far down
      }
    }

    // White dot at bottom (appears after delay)
    if (this.dotVisible){
      const cx = app.w / 2;
      const cy = app.h - 40;
      ctx.beginPath();
      ctx.arc(cx, cy, this.dotRadius, 0, Math.PI*2);
      ctx.fillStyle = '#fff';
      ctx.fill();
    }
  },

  shouldAdvance(app){
    // advance when user hovers the white dot
    return this.dotHoverAdvance;
  }
};

    // Register slides (each is self-contained)
    app.slides = [ Slide1, Slide2, Slide3 ];

    // Main loop
    let tPrev = 0;
    function tick(ts){
      if (!tPrev) tPrev = ts;
      app.dt = Math.min(0.05, (ts - tPrev)/1000); tPrev = ts; app.now = ts/1000;
      const s = app.currentSlide;
      if (s){ s.update?.(app.dt, app); s.render?.(ctx, app); if (s.shouldAdvance?.(app)) app.next(); }
      requestAnimationFrame(tick);
    }

    app.setSize();
    app.goto(0);
    requestAnimationFrame(tick);
  })();
  </script>
</body>
</html>


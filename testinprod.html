<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>together</title>
  <style>
    html, body { margin:0; height:100%; background:#000; }
    body { font-family:"Helvetica Neue", Helvetica, Arial, system-ui, -apple-system, sans-serif; }
    canvas { display:block; width:100%; height:100%; }
  </style>
</head>
<body>
  <canvas id="stage"></canvas>
  <script>
  (function(){
    // ============== Core app / slide lifecycle ==============
    const stage = document.getElementById('stage');
    const ctx = stage.getContext('2d');

    const app = {
      stage, ctx,
      dpr: Math.max(1, Math.min(2, window.devicePixelRatio || 1)),
      w: 0, h: 0, dt: 0, now: 0,
      slideIndex: 0, slides: [], currentSlide: null,
      setSize(){
        this.w = Math.floor(innerWidth * this.dpr);
        this.h = Math.floor(innerHeight * this.dpr);
        stage.width = this.w; stage.height = this.h;
        stage.style.width = innerWidth + 'px';
        stage.style.height = innerHeight + 'px';
        this.currentSlide?.onResize?.(this);
      },
      goto(i){
        this.currentSlide?.destroy?.(this);
        this.slideIndex = (i % this.slides.length + this.slides.length) % this.slides.length;
        this.currentSlide = this.slides[this.slideIndex];
        this.currentSlide?.init?.(this);
      },
      next(){ this.goto(this.slideIndex + 1); }
    };

    // Route input only to active slide
    const pointer = { x:0, y:0, down:false };
    function toPx(e){ const r = stage.getBoundingClientRect(); return { x:(e.clientX-r.left)*app.dpr, y:(e.clientY-r.top)*app.dpr }; }

    stage.addEventListener('pointerdown', e=>{ const p=toPx(e); pointer.x=p.x; pointer.y=p.y; pointer.down=true; app.currentSlide?.onPointerDown?.(e, pointer, app); try{stage.setPointerCapture(e.pointerId);}catch(_){} });
    stage.addEventListener('pointermove', e=>{ const p=toPx(e); pointer.x=p.x; pointer.y=p.y; app.currentSlide?.onPointerMove?.(e, pointer, app); });
    ['pointerup','pointercancel','pointerleave','pointerout'].forEach(t=> stage.addEventListener(t, e=>{ pointer.down=false; app.currentSlide?.onPointerUp?.(e, pointer, app); }));

    // Click anywhere → next slide
    addEventListener('click', ()=> app.next());
    addEventListener('resize', ()=> app.setSize(), { passive:true });

    // ============== Slide 1 (self-contained) ==============
    // Black background; large “together” + small “by quasimatt”.
    // Mouse near/over text erases it (turns those glyph pixels black permanently).
    // When ALL text pixels are erased → advance.
    const Slide1 = {
      name: 'slide-1-erase',
      textCanvas: document.createElement('canvas'),
      tctx: null,
      probe: document.createElement('canvas'),
      pctx: null,
      last: null,
      MAIN: 'together',
      SUB:  'by quasimatt',

      init(app){
        this.tctx = this.textCanvas.getContext('2d');
        this.pctx = this.probe.getContext('2d', { willReadFrequently: true });
        this.probe.width = 160; this.probe.height = 90;
        this.onResize(app);
        this.drawText(app);
      },
      onResize(app){
        this.textCanvas.width = app.w;
        this.textCanvas.height = app.h;
        this.drawText(app);
      },
      brushRadius(app){ return Math.max(60, Math.min(260, Math.floor(app.w * 0.06))); },
      wrapLines(c, text, font, maxW){
        c.font = font; const words = text.split(/\s+/); const lines=[]; let ln='';
        for (const w of words){ const test = ln ? (ln+' '+w) : w;
          if (c.measureText(test).width <= maxW || !ln) ln=test; else { lines.push(ln); ln=w; }
        }
        if (ln) lines.push(ln); return lines;
      },
      drawText(app){
        const c=this.tctx, W=this.textCanvas.width, H=this.textCanvas.height;
        c.setTransform(1,0,0,1,0,0); c.clearRect(0,0,W,H);
        const main = Math.max(120, Math.min(200, Math.floor(W*0.16))); // ≥ 120
        const sub  = Math.max(18,  Math.min(42,  Math.floor(W*0.02)));
        c.fillStyle = '#fff'; c.textAlign='center'; c.textBaseline='middle';
        const mainFont = `800 ${main}px "Helvetica Neue", Helvetica, Arial, system-ui, -apple-system, sans-serif`;
        const subFont  = `400 ${sub}px "Helvetica Neue", Helvetica, Arial, system-ui, -apple-system, sans-serif`;
        const lines = this.wrapLines(c, this.MAIN, mainFont, Math.floor(W*0.9));
        const gap = Math.floor(main*0.18);
        const blockH = lines.length*main + (lines.length-1)*gap + (this.SUB? sub*1.6:0);
        let y = (H - blockH)/2 + main/2;
        c.font = mainFont; for (const L of lines){ c.fillText(L, W/2, y); y += main + gap; }
        if (this.SUB){ c.font = subFont; c.fillText(this.SUB, W/2, y + sub*0.8); }
      },
      stamp(app, x, y){
        const r = this.brushRadius(app);
        const g = this.tctx.createRadialGradient(x,y,0,x,y,r);
        g.addColorStop(0.0,'rgba(0,0,0,1)');
        g.addColorStop(0.6,'rgba(0,0,0,0.6)');
        g.addColorStop(1.0,'rgba(0,0,0,0)');
        this.tctx.globalCompositeOperation='destination-out';
        this.tctx.fillStyle=g; this.tctx.beginPath(); this.tctx.arc(x,y,r,0,Math.PI*2); this.tctx.fill();
        this.tctx.globalCompositeOperation='source-over';
      },
      eraseLine(app, a, b){
        const r = this.brushRadius(app), dx=b.x-a.x, dy=b.y-a.y, d=Math.hypot(dx,dy);
        if (!d){ this.stamp(app, b.x,b.y); return; }
        const step = Math.max(1, r*0.4), n = Math.ceil(d/step);
        for (let i=0;i<=n;i++){ const t=i/n; this.stamp(app, a.x+dx*t, a.y+dy*t); }
      },
      allErased(){
        const p=this.pctx; p.clearRect(0,0,this.probe.width,this.probe.height);
        p.drawImage(this.textCanvas,0,0,this.probe.width,this.probe.height);
        const data=p.getImageData(0,0,this.probe.width,this.probe.height).data;
        for (let i=3;i<data.length;i+=4){ if (data[i]!==0) return false; }
        return true;
      },
      update(){ /* no-op */ },
      render(ctx, app){
        ctx.setTransform(1,0,0,1,0,0);
        ctx.fillStyle='#000'; ctx.fillRect(0,0,app.w,app.h);
        ctx.drawImage(this.textCanvas, 0, 0);
      },
      shouldAdvance(){ return this.allErased(); },
      onPointerDown(e, ptr, app){ this.last = {x:ptr.x,y:ptr.y}; this.stamp(app, ptr.x, ptr.y); },
      onPointerMove(e, ptr, app){
        // Hover/drag erasing so fast moves still fill in
        if (this.last) this.eraseLine(app, this.last, {x:ptr.x,y:ptr.y}); else this.stamp(app, ptr.x, ptr.y);
        this.last = {x:ptr.x, y:ptr.y};
      },
      onPointerUp(){ /* keep last to keep interpolation continuous */ },
      destroy(){ this.last=null; }
    };

    // ============== Slide 2 (self-contained) ==============
    // White background; black sentences scroll right→left.
    // When the LAST sentence's center reaches the screen center: freeze, turn bg black, last sentence white, hold 1s → next slide.
    // ============== Slide 2 (self-contained) ==============
// White background; black sentences scroll right→left.
// Text is larger (~2x) and scrolls 50% faster than original.
const Slide2 = {
  name: 'slide-2-marquee',
  speed: 300, // px/sec @ dpr=1 (50% faster than original 120)
  items: [],
  fontSize: 48, // base; will be recomputed in onResize
  text:
    "i imagine a closeness with others that cannot exist. i compare my relationship to myself with my relationship to others. i have access to my every thought and feeling. i will never have this access for someone else. friends feel like acquaintences. acquaintences feel like strangers. everyone feels far away.",
  nextIndex: 0,
  sentencesCached: [],
  stopped: false,
  holdTimer: 0,
  lastItem: null,

  init(app){
    this.items = [];
    this.stopped = false;
    this.holdTimer = 0;
    this.lastItem = null;
    this.nextIndex = 0;

    this.onResize(app);

    this.sentencesCached = this.text
      .split(/(?<=[.!?])\s+/)
      .map(s => s.trim())
      .filter(Boolean);

    this.spawnNext(app, true);
  },

  onResize(app){
    // Roughly double previous size: was ~app.w * 0.022, now 0.044 with bigger clamps
    this.fontSize = Math.max(
      36,
      Math.min(96, Math.floor(app.w * 0.044))
    );
  },

  measure(text, fs){
    ctx.font = `600 ${fs}px "Helvetica Neue", Helvetica, Arial, system-ui, -apple-system, sans-serif`;
    return Math.ceil(ctx.measureText(text).width);
  },

  pickY(app){
    const margin = Math.max(40, Math.floor(app.h * 0.1));
    const minGap = Math.max(30, Math.floor(this.fontSize * 1.15));
    for (let tries = 0; tries < 20; tries++){
      const y = Math.floor(Math.random() * (app.h - 2 * margin)) + margin;
      let clash = false;
      for (const it of this.items){
        if (Math.abs(it.y - y) < minGap){ clash = true; break; }
      }
      if (!clash) return y;
    }
    return Math.floor(app.h / 2);
  },

  spawnNext(app, initial){
    const sents = this.sentencesCached;
    if (!sents.length) return;
    if (this.nextIndex >= sents.length) return; // stop spawning beyond last

    const text = sents[this.nextIndex++];
    const isLast = (this.nextIndex === sents.length);

    const fs = this.fontSize;
    const w = this.measure(text, fs);
    const y = this.pickY(app);
    const x = app.w + (initial ? 0 : Math.floor(fs * 0.6));

    const item = { text, x, y, w, fs, isLast };
    if (isLast) this.lastItem = item;
    this.items.push(item);
  },

  update(dt, app){
    if (this.stopped){
      this.holdTimer += dt;
      return;
    }

    const dx = this.speed * app.dpr * dt;
    for (const it of this.items) it.x -= dx;

    // Spawn next when the tail's end appears on screen
    const tail = this.items[this.items.length - 1];
    if (tail && (tail.x + tail.w) <= app.w) this.spawnNext(app, false);

    // Remove fully offscreen items
    while (this.items.length && this.items[0].x + this.items[0].w < 0){
      this.items.shift();
    }

    // Stop when last sentence center reaches screen center
    if (this.lastItem){
      const center = this.lastItem.x + this.lastItem.w / 2;
      const target = app.w / 2;
      if (center <= target){
        // snap to perfect center, freeze
        this.lastItem.x = Math.floor(target - this.lastItem.w / 2);
        this.stopped = true;
        // keep only the last item visible
        this.items = [ this.lastItem ];
      }
    }
  },

  render(ctx, app){
    if (!this.stopped){
      // scrolling state: white bg, black text
      ctx.setTransform(1,0,0,1,0,0);
      ctx.fillStyle = '#fff';
      ctx.fillRect(0,0,app.w,app.h);

      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#000';

      for (const it of this.items){
        ctx.font = `600 ${it.fs}px "Helvetica Neue", Helvetica, Arial, system-ui, -apple-system, sans-serif`;
        ctx.fillText(it.text, it.x, it.y);
      }
    } else {
      // frozen state: black bg, last sentence in white, centered
      ctx.setTransform(1,0,0,1,0,0);
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,app.w,app.h);

      if (this.lastItem){
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#fff';
        ctx.font = `600 ${this.lastItem.fs}px "Helvetica Neue", Helvetica, Arial, system-ui, -apple-system, sans-serif`;
        ctx.fillText(this.lastItem.text, this.lastItem.x, this.lastItem.y);
      }
    }
  },

  shouldAdvance(){
    return this.stopped && this.holdTimer >= 1.0;
  },

  destroy(){
    this.items.length = 0;
    this.lastItem = null;
  }
};


// ============== Slide 3: Social graph + scattered typewriter sentences ==============
const Slide3 = {
  name: 'social-graph',
  // graph state
  nodes: [], links: [],
  loaded: false, error: null,
  pointerInside: false, px: 0, py: 0,
  fontPx: 12,
  cutoffISO: '2025-09-22',

  // typewriter text
  text: "we can understand other people through their context. where do they go? what do they do? who do they know?",
  textTimer: 0,
  textDelay: 3.0,      // seconds before text starts
  textSpeed: 90,       // chars per second
  textElapsed: 0,      // since text actually started
  sentences: [],
  sentStates: [],
  sentLayout: [],
  currentSentenceIndex: 0,
  textFontSize: 24,
  textLineHeight: 32,

  // dot state
  dotVisible: false,
  dotRadius: 14,
  dotHoverAdvance: false,
  dotDelayAfterText: 3.0, // seconds after text starts

  // --- lifecycle ---
  init(app){
    this.loaded = false;
    this.error = null;
    this.nodes = [];
    this.links = [];
    this.fontPx = Math.max(14, Math.min(22, Math.floor(app.w * 0.016)));

    // text state
    this.textTimer = 0;
    this.textElapsed = 0;
    this.dotVisible = false;
    this.dotHoverAdvance = false;

    this.parseSentences();
    this.setupSentenceLayout(app);

    this.loadSocial()
      .then(() => {
        this.layoutInit(app);
        this.loaded = true;
      })
      .catch(err => { this.error = String((err && err.message) || err); });
  },

  onResize(app){
    this.fontPx = Math.max(14, Math.min(22, Math.floor(app.w * 0.016)));
    this.setupSentenceLayout(app);
  },

  destroy(){
    this.nodes = [];
    this.links = [];
  },

  // --- input ---
  onPointerMove(e, ptr, app){
    this.pointerInside = true;
    this.px = ptr.x;
    this.py = ptr.y;

    // If the dot is visible, detect hover → request advance
    if (this.dotVisible){
      const cx = app.w / 2;
      const cy = app.h - 40;
      const dx = this.px - cx;
      const dy = this.py - cy;
      if (dx*dx + dy*dy <= this.dotRadius * this.dotRadius){
        this.dotHoverAdvance = true;
      }
    }
  },
  onPointerUp(){ this.pointerInside = false; },

  // --- helpers: text parsing & layout ---
  parseSentences(){
    this.sentences = this.text
      .split(/(?<=[.!?])\s+/)
      .map(s => s.trim())
      .filter(Boolean);

    this.sentStates = this.sentences.map(txt => ({
      text: txt,
      charsShown: 0
    }));
    this.currentSentenceIndex = 0;
  },

  setupSentenceLayout(app){
    if (!this.sentences || !this.sentences.length){
      this.parseSentences();
    }

    const fs = Math.max(22, Math.min(34, Math.floor(app.w * 0.024)));
    this.textFontSize = fs;
    this.textLineHeight = Math.floor(fs * 1.4);

    const W = app.w, H = app.h;
    const sideMargin = Math.floor(W * 0.06);
    const topMargin = 16;

    // Central region where we DON'T want text boxes (so they avoid the graph)
    const avoidRect = {
      x: W * 0.15,
      y: H * 0.15,
      w: W * 0.7,
      h: H * 0.7
    };

    const font = `700 ${fs}px "Helvetica Neue", Helvetica, Arial, system-ui, -apple-system, sans-serif`;

    const wrap = (text, maxW) => {
      ctx.font = font;
      const words = text.split(/\s+/);
      const lines = [];
      let line = '';
      for (const w of words){
        const test = line ? line + ' ' + w : w;
        if (ctx.measureText(test).width <= maxW || !line){
          line = test;
        } else {
          lines.push(line);
          line = w;
        }
      }
      if (line) lines.push(line);
      return lines;
    };

    const intersectsRect = (b, r) => {
      return !(
        b.x + b.w <= r.x ||
        b.x >= r.x + r.w ||
        b.y + b.h <= r.y ||
        b.y >= r.y + r.h
      );
    };

    this.sentLayout = [];

    for (let i = 0; i < this.sentences.length; i++){
      const text = this.sentences[i];

      if (i === 0){
        // FIRST SENTENCE: top band, clamped, and kept above the avoidRect
        const maxW = W - sideMargin * 2;
        const lines = wrap(text, maxW);
        const lineWidths = lines.map(L => ctx.measureText(L).width);
        const textW = Math.min(maxW, Math.max(...lineWidths, 0));
        const textH = lines.length * this.textLineHeight;

        const maxBottom = avoidRect.y - 10;
        let y = topMargin + this.textLineHeight;
        if (y + textH > maxBottom){
          y = maxBottom - textH;
        }
        if (y < topMargin){
          y = topMargin;
        }

        const x = sideMargin;

        const box = { x, y: y - this.textLineHeight, w: textW, h: textH + this.textLineHeight };

        if (intersectsRect(box, avoidRect)){
          const shift = box.y + box.h - avoidRect.y;
          box.y -= shift;
        }

        this.sentLayout.push({
          x,
          y,
          maxW
        });
      } else {
        // SUBSEQUENT SENTENCES: random positions, guaranteed on screen and outside avoidRect
        const maxW = Math.floor(W * 0.4);
        const lines = wrap(text, maxW);
        const lineWidths = lines.map(L => ctx.measureText(L).width);
        const textW = Math.min(maxW, Math.max(...lineWidths, 0));
        const textH = lines.length * this.textLineHeight;

        let best = null;
        const margin = topMargin;

        for (let tries = 0; tries < 60; tries++){
          const x = margin + Math.random() * (W - 2 * margin - textW);
          const y = margin + Math.random() * (H - 2 * margin - textH);

          const box = { x, y: y - this.textLineHeight, w: textW, h: textH + this.textLineHeight };

          if (!intersectsRect(box, avoidRect)){
            best = { x, y, maxW };
            break;
          }
        }

        if (!best){
          // Fallback: place under the avoidRect, still clamped to the screen
          const x = sideMargin;
          const yStart = avoidRect.y + avoidRect.h + 10;
          let y = yStart;
          if (y + textH > H - topMargin){
            y = H - topMargin - textH;
          }
          best = { x, y, maxW };
        }

        this.sentLayout.push(best);
      }
    }
  },

  // --- helpers: data parsing ---
  cutoff(){
    const [Y,M,D] = this.cutoffISO.split('-').map(Number);
    return new Date(Y, M-1, D);
  },

  parseDataDate(code){
    if (!code) return null;
    const s = String(code).trim();
    if (/^\d{6}$/.test(s)){
      const mm = +s.slice(0,2), dd = +s.slice(2,4), yy = +s.slice(4,6);
      return new Date(2000+yy, mm-1, dd);
    }
    if (/^\d{8}$/.test(s)){
      const mm = +s.slice(0,2), dd = +s.slice(2,4), yyyy = +s.slice(4,8);
      return new Date(yyyy, mm-1, dd);
    }
    return null;
  },

  extractAccount(href){
    try {
      const u = new URL(href, location.origin);
      const host = u.hostname.toLowerCase();

      // X / Twitter
      if (host === 'x.com' || host === 'twitter.com' || host === 'mobile.twitter.com'){
        const seg = (u.pathname.split('/').filter(Boolean)[0] || '').replace(/^@/,'');
        if (!seg) return null;
        const handle = seg.toLowerCase();
        return { id:`x:${handle}`, platform:'x', handle, url:`https://twitter.com/${handle}` };
      }
      // Instagram
      if (host === 'instagram.com' || host === 'www.instagram.com' || host === 'm.instagram.com'){
        const p = u.pathname.split('/').filter(Boolean);
        const first = (p[0] || '').toLowerCase();
        const bad = new Set(['p','reel','reels','stories','explore','tv','accounts']);
        if (!first || bad.has(first) || !/^[a-z0-9._]{1,30}$/i.test(first)) return null;
        const handle = first.toLowerCase();
        return { id:`ig:${handle}`, platform:'ig', handle, url:`https://instagram.com/${handle}` };
      }
      return null;
    } catch {
      return null;
    }
  },

  // --- data load (same-origin /social) ---
  async loadSocial(){
    const res = await fetch('/social', { credentials:'same-origin' });
    if (!res.ok) throw new Error('Failed to fetch /social');
    const html = await res.text();
    const doc = new DOMParser().parseFromString(html, 'text/html');

    const cutoff = this.cutoff();
    const ps = Array.from(doc.querySelectorAll("p[data-type='social'][data-date]"));
    const posts = [];
    const meta = new Map();

    for (const el of ps){
      const dt = this.parseDataDate(el.getAttribute('data-date'));
      if (!dt || dt < cutoff) continue;

      const ids = new Set();
      el.querySelectorAll('a[href]').forEach(a => {
        const acc = this.extractAccount(a.getAttribute('href'));
        if (acc){
          ids.add(acc.id);
          if (!meta.has(acc.id)) meta.set(acc.id, acc);
        }
      });
      if (ids.size) posts.push({ date: dt, ids: [...ids] });
    }
    posts.sort((a,b) => a.date - b.date);

    const counts = new Map();
    for (const p of posts){
      for (const id of p.ids){
        counts.set(id, (counts.get(id) || 0) + 1);
      }
    }
    const eligible = [...counts.keys()];
    const elig = new Set(eligible);

    // nodes
    this.nodes = eligible.map(id => ({
      id,
      handle: (meta.get(id)?.handle) || id.split(':').pop(),
      platform: (meta.get(id)?.platform) || 'x',
      url: (meta.get(id)?.url) || '',
      mentions: counts.get(id) || 1,
      x: 0, y: 0, vx: 0, vy: 0,
      r: 6 + Math.min(12, (counts.get(id) || 1) * 1.2)
    }));

    // links (co-mentions)
    const key = (a,b) => a < b ? `${a}|${b}` : `${b}|${a}`;
    const map = new Map();
    for (const p of posts){
      const ids = p.ids.filter(id => elig.has(id));
      for (let i = 0; i < ids.length; i++){
        for (let j = i+1; j < ids.length; j++){
          const k = key(ids[i], ids[j]);
          map.set(k, (map.get(k) || 0) + 1);
        }
      }
    }
    this.links = [];
    for (const [k,v] of map){
      const [a,b] = k.split('|');
      const A = this.nodes.find(n => n.id === a);
      const B = this.nodes.find(n => n.id === b);
      if (A && B) this.links.push({ a:A, b:B, value:v, len:120 });
    }
  },

  // --- layout bootstrap ---
  layoutInit(app){
    const W = app.w, H = app.h;
    const N = this.nodes.length || 1;
    const cols = Math.ceil(Math.sqrt(N));
    this.nodes.forEach((n,i) => {
      const x = (i % cols) / (cols - 1 || 1);
      const y = Math.floor(i / cols) / (cols - 1 || 1);
      n.x = 60 + x * (W - 120) + (Math.random() - 0.5) * 20;
      n.y = 60 + y * (H - 120) + (Math.random() - 0.5) * 20;
      n.vx = 0;
      n.vy = 0;
    });
  },

  // --- typewriter helper ---
  advanceText(dt){
    let remaining = dt;
    const charsPerSec = this.textSpeed;

    while (remaining > 0 && this.currentSentenceIndex < this.sentStates.length){
      const state = this.sentStates[this.currentSentenceIndex];
      const len = state.text.length;
      const charsLeft = len - state.charsShown;

      if (charsLeft <= 0){
        this.currentSentenceIndex++;
        continue;
      }

      const charsThisFrame = charsPerSec * remaining;
      if (charsThisFrame >= charsLeft){
        state.charsShown = len;
        const timeUsed = charsLeft / charsPerSec;
        remaining -= timeUsed;
        this.currentSentenceIndex++;
      } else {
        state.charsShown += charsThisFrame;
        remaining = 0;
      }
    }
  },

  // --- simulation/update ---
  update(dt, app){
    // advance text timers always
    this.textTimer += dt;
    if (this.textTimer >= this.textDelay){
      this.textElapsed += dt;
      this.advanceText(dt);
    }
    if (!this.dotVisible && this.textTimer >= this.textDelay + this.dotDelayAfterText){
      this.dotVisible = true;
    }

    if (!this.loaded || !this.nodes.length) return;

    const W = app.w, H = app.h, cx = W/2, cy = H/2;

    // faster, more lively forces
    const springK   = 0.005;   // was 0.003
    const centerK   = 0.0025;  // was 0.0015
    const friction  = 0.88;    // was 0.93 (less friction = more motion)
    const repelK    = 1400;    // was 900
    const collideK  = 0.20;
    const pad       = 6;

    const pointerK  = 6000;    // stronger reaction to mouse
    const pointerR  = Math.max(100, Math.min(240, Math.floor(Math.min(W,H)*0.18)));
    const pR2       = pointerR * pointerR;

    // pairwise repulsion + soft collision
    for (let i = 0; i < this.nodes.length; i++){
      const a = this.nodes[i];
      for (let j = i+1; j < this.nodes.length; j++){
        const b = this.nodes[j];
        let dx = b.x - a.x;
        let dy = b.y - a.y;
        let d2 = dx*dx + dy*dy;
        if (d2 === 0){
          dx = (Math.random()-0.5) * 1e-3;
          dy = (Math.random()-0.5) * 1e-3;
          d2 = dx*dx + dy*dy;
        }
        const d = Math.sqrt(d2);
        const f = repelK / d2;
        const fx = f * (dx/d);
        const fy = f * (dy/d);
        a.vx -= fx; a.vy -= fy;
        b.vx += fx; b.vy += fy;

        const minD = (a.r + b.r) + pad;
        if (d < minD){
          const push = collideK * (minD - d);
          const pfx = push * (dx/d);
          const pfy = push * (dy/d);
          a.vx -= pfx; a.vy -= pfy;
          b.vx += pfx; b.vy += pfy;
        }
      }
    }

    // springs along links
    for (const l of this.links){
      const a = l.a, b = l.b;
      let dx = b.x - a.x;
      let dy = b.y - a.y;
      const d = Math.hypot(dx, dy) || 1e-6;
      const f = springK * (d - l.len);
      const fx = f * (dx/d);
      const fy = f * (dy/d);
      a.vx += fx; a.vy += fy;
      b.vx -= fx; b.vy -= fy;
    }

    // pointer repulsion
    if (this.pointerInside){
      const px = this.px, py = this.py;
      for (const n of this.nodes){
        const dx = n.x - px;
        const dy = n.y - py;
        const d2 = dx*dx + dy*dy;
        if (d2 < pR2){
          const d = Math.sqrt(d2) || 1e-6;
          const f = pointerK / (d2 + 1);
          n.vx += f * (dx/d);
          n.vy += f * (dy/d);
        }
      }
    }

    // center + integrate with velocity clamp
    const maxV = 4.0; // was 2.2 — let nodes move faster
    for (const n of this.nodes){
      n.vx += (cx - n.x) * centerK;

      n.vx = Math.max(-maxV, Math.min(maxV, n.vx));
      n.vy = Math.max(-maxV, Math.min(maxV, n.vy));

      n.vx *= friction;
      n.vy *= friction;

      n.x += n.vx;
      n.y += n.vy;
    }
  },

  // --- draw (graph fullscreen + scattered text + dot) ---
  render(ctx, app){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,app.w,app.h);

    if (this.loaded){
      // Draw edges (white)
      ctx.globalAlpha = 0.35;
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1;
      for (const l of this.links){
        ctx.beginPath();
        ctx.moveTo(l.a.x, l.a.y);
        ctx.lineTo(l.b.x, l.b.y);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;

      // Draw nodes (white circles)
      for (const n of this.nodes){
        ctx.beginPath();
        ctx.arc(n.x, n.y, n.r, 0, Math.PI*2);
        ctx.fillStyle = '#fff';
        ctx.fill();
      }

      // Draw node labels (NOT bold)
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#fff';
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 3;
      for (const n of this.nodes){
        ctx.font = `${this.fontPx}px "Helvetica Neue", Helvetica, Arial, system-ui, -apple-system, sans-serif`;
        const label = `@${n.handle}`;
        ctx.strokeText(label, n.x, n.y);
        ctx.fillText(label,  n.x, n.y);
      }
    }

    // --- scattered typewriter text ---
    if (this.textTimer >= this.textDelay){
      const fs = this.textFontSize;
      const lh = this.textLineHeight;
      const font = `700 ${fs}px "Helvetica Neue", Helvetica, Arial, system-ui, -apple-system, sans-serif`;
      const padX = 10;
      const padY = 6;

      ctx.textBaseline = 'alphabetic';
      ctx.font = font;

      const wrap = (text, maxW) => {
        ctx.font = font;
        const words = text.split(/\s+/);
        const lines = [];
        let line = '';
        for (const w of words){
          const test = line ? line + ' ' + w : w;
          if (ctx.measureText(test).width <= maxW || !line){
            line = test;
          } else {
            lines.push(line);
            line = w;
          }
        }
        if (line) lines.push(line);
        return lines;
      };

      for (let i = 0; i < this.sentStates.length; i++){
        const st = this.sentStates[i];
        const layout = this.sentLayout[i];
        if (!layout) continue;

        const shown = st.text.slice(0, Math.floor(st.charsShown));
        if (!shown) continue;

        const lines = wrap(shown, layout.maxW);
        let y = layout.y;
        const xStart = layout.x;

        for (const L of lines){
          const w = ctx.measureText(L).width;
          // tight black box behind line
          ctx.fillStyle = '#000';
          ctx.fillRect(
            xStart - padX,
            y - lh - padY,
            w + padX*2,
            lh + padY*2
          );
          // white bold text
          ctx.fillStyle = '#fff';
          ctx.fillText(L, xStart, y);
          y += lh;
        }
      }
    }

    // White dot at bottom (appears after delay)
    if (this.dotVisible){
      const cx = app.w / 2;
      const cy = app.h - 40;
      ctx.beginPath();
      ctx.arc(cx, cy, this.dotRadius, 0, Math.PI*2);
      ctx.fillStyle = '#fff';
      ctx.fill();
    }
  },

  shouldAdvance(app){
    // advance when user hovers the white dot
    return this.dotHoverAdvance;
  }
};


    // Register slides (each is self-contained)
    app.slides = [ Slide1, Slide2, Slide3 ];

    // Main loop
    let tPrev = 0;
    function tick(ts){
      if (!tPrev) tPrev = ts;
      app.dt = Math.min(0.05, (ts - tPrev)/1000); tPrev = ts; app.now = ts/1000;
      const s = app.currentSlide;
      if (s){ s.update?.(app.dt, app); s.render?.(ctx, app); if (s.shouldAdvance?.(app)) app.next(); }
      requestAnimationFrame(tick);
    }

    app.setSize();
    app.goto(0);
    requestAnimationFrame(tick);
  })();
  </script>
</body>
</html>


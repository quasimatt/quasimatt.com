<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>quasi â€“ eraser text (flip on clear)</title>
  <style>
    html, body { height:100%; margin:0; background:#000; }
    body { font-family: "Helvetica Neue", Helvetica, Arial, system-ui, -apple-system, sans-serif; }
    canvas { display:block; width:100%; height:100%; }
  </style>
</head>
<body>
  <canvas id="stage" aria-label="Interactive text canvas"></canvas>
  <script>
  (function(){
    var stage = document.getElementById("stage");
    var sctx = stage.getContext("2d");

    // Offscreen for text bitmap that we erase from
    var textCanvas = document.createElement("canvas");
    var tctx = textCanvas.getContext("2d");

    // Tiny probe canvas to check when all text is erased
    var probe = document.createElement("canvas");
    var pctx = probe.getContext("2d", { willReadFrequently: true });
    probe.width = 160; probe.height = 90;

    var dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    var inverted = false; // false: bg black, text white. true: bg white, text black
    var dirty = true;
    var lastCheck = 0;

    var MAIN = "at least we're together";
    var SUB  = "by quasimatt";

    function resize(){
      var w = Math.floor(innerWidth * dpr);
      var h = Math.floor(innerHeight * dpr);
      stage.width = w; stage.height = h;
      stage.style.width = innerWidth + "px";
      stage.style.height = innerHeight + "px";
      textCanvas.width = w; textCanvas.height = h;
      drawText();
      dirty = true;
    }

    function wrapLines(ctx, text, font, maxWidth){
      ctx.font = font;
      var words = text.split(" ");
      var lines = [];
      var line = "";
      for (var i=0;i<words.length;i++){
        var w = words[i];
        var test = line ? line + " " + w : w;
        if (ctx.measureText(test).width <= maxWidth || !line) line = test;
        else { lines.push(line); line = w; }
      }
      if (line) lines.push(line);
      return lines;
    }

    function drawText(){
      var W = textCanvas.width, H = textCanvas.height;
      tctx.setTransform(1,0,0,1,0,0);
      tctx.clearRect(0,0,W,H);

      var mainSize = Math.max(26, Math.min(120, Math.floor(W * 0.055)));
      var subSize  = Math.max(12, Math.min(34,  Math.floor(W * 0.02)));

      var fg = inverted ? "#000" : "#fff"; // text color depends on background
      tctx.fillStyle = fg;
      tctx.textAlign = "center";
      tctx.textBaseline = "middle";

      var mainFont = "700 " + mainSize + "px \"Helvetica Neue\", Helvetica, Arial, system-ui, -apple-system, sans-serif";
      var subFont  = "400 " + subSize  + "px \"Helvetica Neue\", Helvetica, Arial, system-ui, -apple-system, sans-serif";

      var maxTextWidth = Math.floor(W * 0.8);
      var lines = wrapLines(tctx, MAIN, mainFont, maxTextWidth);
      var lineGap = Math.floor(mainSize * 0.35);
      var blockHeight = lines.length * mainSize + (lines.length - 1) * lineGap + (subSize * 1.6);
      var y = (H - blockHeight) / 2 + mainSize/2;

      tctx.font = mainFont;
      for (var j=0;j<lines.length;j++){
        tctx.fillText(lines[j], W/2, y);
        y += mainSize + lineGap;
      }
      tctx.font = subFont;
      tctx.fillText(SUB, W/2, y + subSize*0.8);

      dirty = true;
    }

    function paint(){
      if (!dirty) return;
      dirty = false;
      var bg = inverted ? "#fff" : "#000";
      sctx.setTransform(1,0,0,1,0,0);
      sctx.fillStyle = bg;
      sctx.fillRect(0,0,stage.width,stage.height);
      sctx.drawImage(textCanvas, 0, 0);
    }

    // ----- Brush helpers -----
    function baseBrush(){
      // original was stage.width * 0.04 with min 40 and max 160
      // increase radius by 50% and adjust clamps accordingly
      var b = stage.width * 0.04 * 1.5;
      return Math.max(60, Math.min(240, Math.floor(b)));
    }

    function eraseStamp(x, y, r){
      var g = tctx.createRadialGradient(x, y, 0, x, y, r);
      g.addColorStop(0.0, "rgba(0,0,0,1)");
      g.addColorStop(0.6, "rgba(0,0,0,0.6)");
      g.addColorStop(1.0, "rgba(0,0,0,0)");
      tctx.globalCompositeOperation = "destination-out"; // erase to transparent
      tctx.fillStyle = g;
      tctx.beginPath();
      tctx.arc(x, y, r, 0, Math.PI * 2);
      tctx.fill();
      tctx.globalCompositeOperation = "source-over";
      dirty = true;
    }

    function eraseLine(x0, y0, x1, y1){
      var r = baseBrush();
      var dx = x1 - x0, dy = y1 - y0;
      var dist = Math.hypot(dx, dy);
      if (dist === 0){ eraseStamp(x1, y1, r); return; }
      // step at half-radius to avoid gaps at high pointer velocity
      var step = Math.max(1, r * 0.5);
      var n = Math.ceil(dist / step);
      for (var i = 0; i <= n; i++){
        var t = i / n;
        var x = x0 + dx * t;
        var y = y0 + dy * t;
        eraseStamp(x, y, r);
      }
    }

    // ----- Input handling with interpolation -----
    var lastPt = null;

    function toPx(evt){
      var rect = stage.getBoundingClientRect();
      return { x: (evt.clientX - rect.left) * dpr, y: (evt.clientY - rect.top) * dpr };
    }

    stage.addEventListener("pointerdown", function(e){
      var p = toPx(e);
      eraseStamp(p.x, p.y, baseBrush());
      lastPt = p;
      try { stage.setPointerCapture(e.pointerId); } catch(_){}
    });

    stage.addEventListener("pointermove", function(e){
      var p = toPx(e);
      if (lastPt){ eraseLine(lastPt.x, lastPt.y, p.x, p.y); }
      else { eraseStamp(p.x, p.y, baseBrush()); }
      lastPt = p;
    });

    ["pointerup","pointercancel","pointerleave","pointerout"].forEach(function(type){
      stage.addEventListener(type, function(){ lastPt = null; });
    });

    function allErased(){
      pctx.clearRect(0,0,probe.width,probe.height);
      pctx.drawImage(textCanvas, 0, 0, probe.width, probe.height);
      var data = pctx.getImageData(0,0,probe.width,probe.height).data;
      for (var i=3;i<data.length;i+=4){ if (data[i] !== 0) return false; }
      return true;
    }

    addEventListener("keydown", function(e){ if ((e.key||"").toLowerCase()==="r") drawText(); });

    function loop(ts){
      paint();
      if (!lastCheck || ts - lastCheck > 100){
        lastCheck = ts;
        if (allErased()){
          inverted = !inverted;  // flip background color
          drawText();            // redraw text in opposite color
        }
      }
      requestAnimationFrame(loop);
    }

    addEventListener("resize", resize, { passive: true });
    resize();
    requestAnimationFrame(loop);
  })();
  </script>
</body>
</html>

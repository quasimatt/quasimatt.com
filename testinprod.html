<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>together</title>
  <style>
    html, body { height:100%; margin:0; background:#000; }
    body { font-family: "Helvetica Neue", Helvetica, Arial, system-ui, -apple-system, sans-serif; }
    canvas { display:block; width:100%; height:100%; }
  </style>
</head>
<body>
  <canvas id="stage" aria-label="Interactive text canvas"></canvas>
  <script>
  (function(){
    const stage = document.getElementById('stage');
    const ctx = stage.getContext('2d');
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    function setSize(){
      stage.width  = Math.floor(innerWidth * dpr);
      stage.height = Math.floor(innerHeight * dpr);
      stage.style.width  = innerWidth + 'px';
      stage.style.height = innerHeight + 'px';
      resizeAll();
    }
    addEventListener('resize', setSize, {passive:true});

    // Slide manager
    let slideIndex = 0; // 0 = erase/flip loop, 1 = world scroll (unveil vs erase)
    function nextSlide(){
      slideIndex = (slideIndex + 1);
      if (slideIndex === 1) slide1_init();
    }

    // ========= Slide 0: erase/flip loop =========
    const s0 = {
      textCanvas: document.createElement('canvas'),
      tctx: null,
      probe: document.createElement('canvas'),
      pctx: null,
      lastPt: null,
      lastCheck: 0,
      inverted: false
    };
    s0.tctx = s0.textCanvas.getContext('2d');
    s0.pctx = s0.probe.getContext('2d', { willReadFrequently: true });
    s0.probe.width = 160; s0.probe.height = 90;

    const MAIN = "i don't think i belong here but i don't know where to go";
    const SUB  = "by quasimatt";

    function s0_resize(){
      s0.textCanvas.width = stage.width;
      s0.textCanvas.height = stage.height;
      s0_drawText();
    }

    function wrapLines(c, text, font, maxWidth){
      c.font = font;
      const words = text.split(/\s+/);
      const lines = []; let line = '';
      for (let i=0;i<words.length;i++){
        const test = line ? (line + ' ' + words[i]) : words[i];
        if (c.measureText(test).width <= maxWidth || !line) line = test; else { lines.push(line); line = words[i]; }
      }
      if (line) lines.push(line);
      return lines;
    }

    function s0_drawText(){
      const W = s0.textCanvas.width, H = s0.textCanvas.height;
      const c = s0.tctx;
      c.setTransform(1,0,0,1,0,0);
      c.clearRect(0,0,W,H);

      const mainSize = Math.max(26, Math.min(120, Math.floor(W * 0.055)));
      const subSize  = Math.max(12, Math.min(34,  Math.floor(W * 0.02)));

      const fg = s0.inverted ? '#000' : '#fff';
      c.fillStyle = fg;
      c.textAlign = 'center';
      c.textBaseline = 'middle';

      const mainFont = '700 ' + mainSize + 'px "Helvetica Neue", Helvetica, Arial, system-ui, -apple-system, sans-serif';
      const subFont  = '400 ' + subSize  + 'px "Helvetica Neue", Helvetica, Arial, system-ui, -apple-system, sans-serif';

      const maxTextWidth = Math.floor(W * 0.8);
      const lines = wrapLines(c, MAIN, mainFont, maxTextWidth);
      const lineGap = Math.floor(mainSize * 0.35);
      const blockHeight = lines.length * mainSize + (lines.length - 1) * lineGap + (subSize * 1.6);
      let y = (H - blockHeight) / 2 + mainSize/2;

      c.font = mainFont;
      for (let j=0;j<lines.length;j++){ c.fillText(lines[j], W/2, y); y += mainSize + lineGap; }
      c.font = subFont;
      c.fillText(SUB, W/2, y + subSize*0.8);
    }

    function s0_paint(){
      const bg = s0.inverted ? '#fff' : '#000';
      ctx.setTransform(1,0,0,1,0,0);
      ctx.fillStyle = bg;
      ctx.fillRect(0,0,stage.width,stage.height);
      ctx.drawImage(s0.textCanvas, 0, 0);
    }

    function s0_brushRadius(){
      const b = stage.width * 0.04 * 1.5; // +50%
      return Math.max(60, Math.min(240, Math.floor(b)));
    }
    function s0_eraseStamp(x,y,r){
      const g = s0.tctx.createRadialGradient(x, y, 0, x, y, r);
      g.addColorStop(0.0, 'rgba(0,0,0,1)');
      g.addColorStop(0.6, 'rgba(0,0,0,0.6)');
      g.addColorStop(1.0, 'rgba(0,0,0,0)');
      s0.tctx.globalCompositeOperation = 'destination-out';
      s0.tctx.fillStyle = g;
      s0.tctx.beginPath(); s0.tctx.arc(x,y,r,0,Math.PI*2); s0.tctx.fill();
      s0.tctx.globalCompositeOperation = 'source-over';
    }
    function s0_eraseLine(x0,y0,x1,y1){
      const r = s0_brushRadius();
      const dx = x1-x0, dy=y1-y0; const dist = Math.hypot(dx,dy);
      if (dist===0){ s0_eraseStamp(x1,y1,r); return; }
      const step = Math.max(1, r*0.5);
      const n = Math.ceil(dist/step);
      for (let i=0;i<=n;i++){ const t=i/n; s0_eraseStamp(x0+dx*t, y0+dy*t, r); }
    }
    function s0_allErased(){
      s0.pctx.clearRect(0,0,s0.probe.width,s0.probe.height);
      s0.pctx.drawImage(s0.textCanvas, 0, 0, s0.probe.width, s0.probe.height);
      const data = s0.pctx.getImageData(0,0,s0.probe.width,s0.probe.height).data;
      for (let i=3;i<data.length;i+=4){ if (data[i]!==0) return false; }
      return true;
    }

    function s0_toPx(evt){ const r=stage.getBoundingClientRect(); return {x:(evt.clientX-r.left)*dpr, y:(evt.clientY-r.top)*dpr}; }
    stage.addEventListener('pointerdown',  e=>{ if (slideIndex!==0) return; const p=s0_toPx(e); s0_eraseStamp(p.x,p.y,s0_brushRadius()); s0.lastPt=p; try{stage.setPointerCapture(e.pointerId);}catch(_){} });
    stage.addEventListener('pointermove',  e=>{ if (slideIndex!==0) return; const p=s0_toPx(e); if (s0.lastPt) s0_eraseLine(s0.lastPt.x,s0.lastPt.y,p.x,p.y); else s0_eraseStamp(p.x,p.y,s0_brushRadius()); s0.lastPt=p; });
    ['pointerup','pointercancel','pointerleave','pointerout'].forEach(t=> stage.addEventListener(t, ()=>{ s0.lastPt=null; }));

    // ========= Slide 1: world scroll; trail unveils black text and erases white text (white never inverts) =========
    const s1 = {
      mask: document.createElement('canvas'), // screen-space mask (white=trail)
      mctx: null,
      tmp: document.createElement('canvas'),
      tctx: null,
      itemsWhite: [],
      itemsBlack: [],
      speed: 120, // px/sec @ dpr=1
      pointer: {x:0,y:0,over:false}
    };
    s1.mctx = s1.mask.getContext('2d');
    s1.tctx = s1.tmp.getContext('2d');

    const sentencesWhite = (
      "we got drunk on christmas. i told you i felt like the bar was too high. we can't know people the way we know ourselves. we feel lonely because we imagine a closeness we can never reach. we need to lower our standards."
    ).split('.').map(s => (s.trim()? s.trim()+'.' : '').trim()).filter(Boolean);

    const sentencesBlack = (
      "the next day you told me that was the most honest conversation we had ever had. i was confused. i'm almost always honest. does honesty really come in degrees? you never told me whether you agreed. i still don't know."
    ).split('.').map(s => (s.trim()? s.trim()+'.' : '').trim()).filter(Boolean);

    function s1_resize(){
      s1.mask.width = stage.width; s1.mask.height = stage.height;
      s1.tmp.width  = stage.width; s1.tmp.height  = stage.height;
      s1.mctx.setTransform(1,0,0,1,0,0); s1.mctx.clearRect(0,0,s1.mask.width,s1.mask.height);
    }
    function s1_fontSize(){ return Math.max(18, Math.min(42, Math.floor(stage.width * 0.02))); }

    function pickYNonOverlapping(){
      const margin = Math.max(40, Math.floor(stage.height*0.1));
      let y, tries=0, minGap = 36;
      function clashes(Y){
        const all = s1.itemsWhite.concat(s1.itemsBlack);
        for (let i=0;i<all.length;i++) if (Math.abs(all[i].y - Y) < minGap) return true;
        return false;
      }
      do { y = Math.floor(Math.random()*(stage.height - 2*margin)) + margin; tries++; }
      while (clashes(y) && tries < 12);
      return y;
    }

    function s1_spawn(isWhite, initial){
      const pool = isWhite ? sentencesWhite : sentencesBlack;
      const key = isWhite ? '_idxW' : '_idxB';
      if (typeof s1_spawn[key] !== 'number') s1_spawn[key] = -1;
      const next = (s1_spawn[key] + 1) % pool.length; s1_spawn[key] = next;
      const text = pool[next];
      const font = (isWhite? '400 ':'600 ') + s1_fontSize() + 'px "Helvetica Neue", Helvetica, Arial, system-ui, -apple-system, sans-serif';
      ctx.font = font; const w = Math.ceil(ctx.measureText(text).width);
      const item = { text, font, x: stage.width + (initial?0: Math.floor(s1_fontSize()*0.5)), y: pickYNonOverlapping(), w };
      if (isWhite) s1.itemsWhite.push(item); else s1.itemsBlack.push(item);
    }

    function s1_shiftMaskLeft(dx){
      s1.tctx.setTransform(1,0,0,1,0,0);
      s1.tctx.clearRect(0,0,s1.tmp.width,s1.tmp.height);
      s1.tctx.drawImage(s1.mask, 0, 0);
      s1.mctx.setTransform(1,0,0,1,0,0);
      s1.mctx.clearRect(0,0,s1.mask.width,s1.mask.height);
      s1.mctx.drawImage(s1.tmp, -dx, 0);
    }

    function s1_stampTrail(x,y){
      const r = s0_brushRadius();
      const g = s1.mctx.createRadialGradient(x,y,0,x,y,r);
      g.addColorStop(0.0, 'rgba(255,255,255,1)');
      g.addColorStop(0.6, 'rgba(255,255,255,0.6)');
      g.addColorStop(1.0, 'rgba(255,255,255,0)');
      s1.mctx.globalCompositeOperation = 'lighter';
      s1.mctx.fillStyle = g;
      s1.mctx.beginPath(); s1.mctx.arc(x,y,r,0,Math.PI*2); s1.mctx.fill();
      s1.mctx.globalCompositeOperation = 'source-over';
    }

    function slide1_init(){
      s1.itemsWhite.length = 0; s1.itemsBlack.length = 0;
      s1_resize();
      s1_spawn(true,  true);
      s1_spawn(false, true);
    }

    function slide1_update(dt){
      const px = s1.speed * dpr * dt;
      s1_shiftMaskLeft(px);
      for (let i=0;i<s1.itemsWhite.length;i++) s1.itemsWhite[i].x -= px;
      for (let j=0;j<s1.itemsBlack.length;j++) s1.itemsBlack[j].x -= px;

      const lastW = s1.itemsWhite[s1.itemsWhite.length-1];
      if (lastW && (lastW.x + lastW.w <= stage.width)) s1_spawn(true, false);
      const lastB = s1.itemsBlack[s1.itemsBlack.length-1];
      if (lastB && (lastB.x + lastB.w <= stage.width)) s1_spawn(false, false);

      while (s1.itemsWhite.length && s1.itemsWhite[0].x + s1.itemsWhite[0].w < 0) s1.itemsWhite.shift();
      while (s1.itemsBlack.length && s1.itemsBlack[0].x + s1.itemsBlack[0].w < 0) s1.itemsBlack.shift();

      if (s1.pointer.over) s1_stampTrail(s1.pointer.x, s1.pointer.y);
    }

    function slide1_render(){
      // base: black bg
      ctx.setTransform(1,0,0,1,0,0);
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,stage.width,stage.height);

      // invert ONLY the background (before any text)
      ctx.globalCompositeOperation = 'difference';
      ctx.drawImage(s1.mask, 0, 0);
      ctx.globalCompositeOperation = 'source-over';

      // black sentences (visible where bg is white)
      ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
      ctx.fillStyle = '#000';
      for (let b=0;b<s1.itemsBlack.length;b++){ const bt = s1.itemsBlack[b]; ctx.font = bt.font; ctx.fillText(bt.text, bt.x, bt.y); }

      // white sentences (never inverted)
      ctx.fillStyle = '#fff';
      for (let w=0; w<s1.itemsWhite.length; w++){ const it = s1.itemsWhite[w]; ctx.font = it.font; ctx.fillText(it.text, it.x, it.y); }

      // erase white sentences where trail passes
      ctx.globalCompositeOperation = 'destination-out';
      ctx.drawImage(s1.mask, 0, 0);
      ctx.globalCompositeOperation = 'source-over';
    }

    // pointer for slide 1
    function toPx(evt){ const r=stage.getBoundingClientRect(); return {x:(evt.clientX-r.left)*dpr, y:(evt.clientY-r.top)*dpr}; }
    stage.addEventListener('pointermove', e => { const p = toPx(e); if (slideIndex===1){ s1.pointer.x=p.x; s1.pointer.y=p.y; s1.pointer.over=true; }});
    ['pointerleave','pointerout','pointercancel'].forEach(t=> stage.addEventListener(t, ()=>{ if(slideIndex===1){ s1.pointer.over=false; } }));

    // frame loop
    let tPrev=0;
    function tick(ts){
      if (!tPrev) tPrev = ts; const dt = Math.min(0.05, (ts - tPrev)/1000); tPrev = ts;
      if (slideIndex === 0){
        s0_paint();
        if (s0.lastCheck === 0 || ts - s0.lastCheck > 100){
          s0.lastCheck = ts;
          if (s0_allErased()){ s0.inverted = !s0.inverted; s0_drawText(); }
        }
      } else {
        slide1_update(dt);
        slide1_render();
      }
      requestAnimationFrame(tick);
    }

    // click to advance from slide 0 â†’ 1
    addEventListener('click', () => { if (slideIndex===0){ slideIndex=1; slide1_init(); } });

    function resizeAll(){ if (slideIndex===0) s0_resize(); else s1_resize(); }
    setSize();
    requestAnimationFrame(tick);
  })();
  </script>
</body>
</html>
